#include "fun_head.h"
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>


const int numHouseholds = 100;
const int numFirms = 50;
const char* sectors[] = { "Agriculture", "Energy", "Housing", "Transport", "Industry", "Technology" };

struct Household {
    int status;
    int assignedSector;
    double salary = 0.0;
    int IdFirm = -1;  // L'identifiant de la firme, -1 signifie qu'il n'a pas encore d'employeur
};

struct Firm {
    std::string sector;
    double salaryShareBrown = 0;
    double salaryShareGreen = 0;
    double salaryBrown = 1000;
    double salaryGreen = 1200;
};

Household households[numHouseholds];
Firm firms[numFirms];

class Model {
public:
    void initializeFirms() {
        for (int i = 0; i < numFirms; ++i) {
            firms[i].sector = sectors[i % 6];
        }
    }

    void initializeHouseholds() {
        for (int i = 0; i < numHouseholds; ++i) {
            float randValue = static_cast<float>(rand()) / RAND_MAX;

            if (randValue < 0.3) {
                households[i].status = 0;
                households[i].salary = 0.0;
                households[i].IdFirm = -1; // Pas de firme assignée
            } else if (randValue < 0.7) {
                households[i].status = 1;
                int firmIndex = rand() % numFirms;
                households[i].salary = firms[firmIndex].salaryBrown;
                households[i].assignedSector = rand() % 6;
                households[i].IdFirm = firmIndex; // Assigner l'ID de la firme
            } else {
                households[i].status = 2;
                int firmIndex = rand() % numFirms;
                households[i].salary = firms[firmIndex].salaryGreen;
                households[i].assignedSector = rand() % 6;
                households[i].IdFirm = firmIndex; // Assigner l'ID de la firme
            }
        }
    }

    void displayHouseholds() {
        for (int i = 0; i < 10; ++i) {
            std::cout << "Household " << i << " | Status: " << households[i].status
                      << " | Sector Assigned: " << households[i].assignedSector
                      << " | Salary: " << households[i].salary
                      << " | Firm ID: " << households[i].IdFirm << std::endl;
        }
    }
};

Model model;



MODELBEGIN

    // Initialisation du modèle

    model.initializeFirms();
    model.initializeHouseholds();
    model.displayHouseholds();



/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/
/*EQUATIONS D'INITALISATION*/



















/*EQUATIONS GENERALES*/
/*EQUATIONS GENERALES*/
/*EQUATIONS GENERALES*/
/*EQUATIONS GENERALES*/
/*EQUATIONS GENERALES*/
/*EQUATIONS GENERALES*/
/*EQUATIONS GENERALES*/
/*EQUATIONS GENERALES*/









/*POLITIQUES PUBLIQUES*/ 
/*POLITIQUES PUBLIQUES*/
/*POLITIQUES PUBLIQUES*/
/*POLITIQUES PUBLIQUES*/
/*POLITIQUES PUBLIQUES*/
/*POLITIQUES PUBLIQUES*/
/*POLITIQUES PUBLIQUES*/
/*POLITIQUES PUBLIQUES*/




/*FINANCING AND STATE BUDGET*/
/*FINANCING AND STATE BUDGET*/


EQUATION("GovernmentDeficit")
/*
Calcul du déficit public.
Le déficit augmente avec les dépenses et diminue avec les revenus.
*/

// Variables représentant les dépenses publiques
v[0] = V("UnemploymentBenefitProgramme");  // Coût des allocations chômage
v[1] = V("CostJobGuarantee");              // Coût du programme d'emploi garanti
v[2] = V("TotalRed");                           // Autres transferts ou aides
v[3] = V("PubSpendPubServ");               // Dépenses pour les services publics
v[4] = V("ReskillingProgrammeCost");       // Coût du programme de requalification professionnelle
v[5] = V("TotalPublicInvestment");         // Total des investissements publics
v[6] = V("TotalSubsidies");                // Total des subventions publiques

// Variables représentant les revenus publics
v[7] = V("Taxes");                         // Recettes fiscales
v[8] = V("CentralBankProfits");            // Profits de la banque centrale
v[9] = V("TotalPenalties");                // Recettes issues des pénalités

// Calcul du déficit public : dépenses - revenus
v[10] = (v[0] + v[1] + v[2] + v[3] + v[4] + v[5] + v[6])  // Total des dépenses
      - (v[7] + v[8] + v[9]);                            // Total des revenus

RESULT(v[10])



EQUATION("GovernmentBonds")
/*
Calcul de l'émission ou du remboursement d'obligations gouvernementales pour financer le déficit.
*/

// Récupérer le déficit du gouvernement pour cette période
v[0] = V("GovernmentDeficit");  // Déficit calculé dans l'équation correspondante

// Obligations émises ou remboursées
v[1] = VL("GovernmentBonds", 1);  // Stock d'obligations à la période précédente

// Mise à jour du stock d'obligations
v[2] = v[1] + v[0];  // Ajouter le déficit (positif ou négatif) au stock précédent

RESULT(v[2])


EQUATION("InterestRatePublicDebt")
/*
Calcul du taux d'intérêt sur la dette publique.
Le taux est poussé à la hausse par le ratio Dette/PIB et réduit par la variation des Bonds achetés par la BCE.
*/

// Récupérer les variables nécessaires
v[0] = V("GovernmentDebt");           // Stock total de la dette publique
v[1] = V("GDP");                      // Produit Intérieur Brut (PIB)
v[2] = V("BondsPurchasedByECB");      // Obligations achetées par la BCE à cette période
v[3] = VL("BondsPurchasedByECB", 1); // Obligations achetées par la BCE à la période précédente
v[4] = VL("InterestRatePublicDebt", 1); // Taux d'intérêt sur la dette publique à la période précédente

// Paramètres du modèle
v[5] = 0.05;  // Sensibilité à l'augmentation du ratio Dette/PIB
v[6] = 0.03;  // Sensibilité à la baisse liée aux achats d'obligations de la BCE

// Calcul du ratio Dette/PIB
if (v[1] > 0) {
    v[7] = v[0] / v[1];  // Ratio Dette/PIB
} else {
    v[7] = 0;            // Éviter les divisions par zéro
}

// Calcul de la variation des achats d'obligations de la BCE
v[8] = v[2] - v[3]; // Variation des Bonds achetés par la BCE

// Ajustement du taux d'intérêt
v[9] = v[4] + v[5] * v[7];  // Hausse due au ratio Dette/PIB
v[9] = v[9] - v[6] * v[8];  // Baisse due aux achats d'obligations de la BCE

RESULT(v[9])



/*JOB GUARANTEE*/
/*JOB GUARANTEE*/



EQUATION("TakePublicJob")
/*
Prise de décision d'un agent au chômage pour accepter ou non un emploi garanti par l'État.
Retourne 1 si l'agent accepte l'emploi, 0 sinon.
Met à jour la variable "Status" à 3 en cas d'acceptation.
*/

// Variables influençant la décision
v[0] = V("UnemploymentBenefit");  // Allocation chômage de l'agent
v[1] = V("WagePublicJobs");       // Salaire proposé par l'emploi garanti
v[2] = V("DistanceToJob");        // Distance ou coût de déplacement vers l'emploi garanti
v[3] = V("JobGuaranteeProgram");  // État du programme de garantie d'emploi (1 = actif, 0 = inactif)

// Calcul du gain net lié à l'emploi public
v[4] = v[3] * (v[1] - v[0] - v[2]);  // Gain net : (salaire public - allocation - coût de déplacement)

// Décision de l'agent
if (v[4] > 0) {
    WRITE("Status", 3);  // Met à jour le statut à 3 (emploi garanti accepté)
    v[5] = 1;            // Décision : accepter l'emploi
} else {
    v[5] = 0;            // Décision : refuser l'emploi
}

// Résultat de l'équation
RESULT(v[5])




EQUATION("CostJobGuarantee")
/*
Calcul des coûts totaux liés au programme de garantie d'emploi.
Le coût est égal à la somme des rémunérations des bénéficiaires (statut = 3), payés au salaire minimum.
*/

// Initialisation du coût total
v[0] = V("MinimumWage");  // Salaire minimum
v[1] = 0;                 // Coût total initialisé à 0

CYCLE(cur, "Households") { // Parcours de tous les agents dans la branche "Households"
    if (VS(cur, "Status") == 3) {  // Vérifie si l'agent est dans le programme (statut = 3)
        v[1] += v[0];              // Ajoute le salaire minimum au coût total
    }
}

RESULT(v[1])  // Retourne le coût total



/*RESKILLING PROGRAMME*/
/*RESKILLING PROGRAMME*/



EQUATION("ReskillingPolicy")
/*
Modélisation d'une politique de requalification professionnelle.
Les agents LowSkilled (SkillStatus = 1) peuvent participer à un programme de formation.
Pendant leur formation (deux périodes), ils ne sont rémunérés qu'au niveau de l'UnemploymentBenefit,
et leur variable Status est mise à jour pour refléter leur participation au programme (Status = 5).
*/

// Initialisation des compteurs
v[0] = 0;  // Nombre total d'agents en formation
v[1] = 0;  // Nombre total d'agents ayant terminé leur formation
v[2] = V("UnemploymentBenefit");  // Allocation chômage

CYCLE(cur, "Households") {  // Parcours de tous les agents de la branche "Households"
    if (VS(cur, "SkillStatus") == 1) {  // Si l'agent est LowSkilled (travailleur peu qualifié)
        if (VS(cur, "ReskillingTimer") == 0) {  // Si l'agent n'est pas déjà en formation
            v[3] = RND;  // Tirage aléatoire pour simuler la décision d'entrer en formation
            if (v[3] < 0.5) {  // Seulement 50 % des agents acceptent de se requalifier
                WRITES(cur, "ReskillingTimer", 1);  // Démarre la formation (période 1)
                WRITES(cur, "Salary", v[2]);        // Rémunération limitée à UnemploymentBenefit
                WRITES(cur, "Status", 5);          // Met à jour Status à 5 pour représenter la formation
                v[0] += 1;  // Incrémente le compteur des agents en formation
            }
        }
    } else if (VS(cur, "ReskillingTimer") > 0) {  // Si l'agent est déjà en formation
        v[4] = VS(cur, "ReskillingTimer") + 1;  // Incrémente le timer de formation
        WRITES(cur, "ReskillingTimer", v[4]);  // Met à jour le timer

        if (v[4] >= 2) {  // Si la formation est terminée (après deux périodes)
            WRITES(cur, "SkillStatus", 2);     // Change le statut à HighSkilled
            WRITES(cur, "ReskillingTimer", 0); // Réinitialise le timer
            WRITES(cur, "Status", 0);         // Réinitialise le Status à 0 (ou valeur par défaut)
            v[1] += 1;                         // Incrémente le compteur des agents formés
        }
    }
}

// Résultat : Retourne le nombre d'agents actuellement en formation
RESULT(v[0])




/*SUBSIDIES*/
/*SUBSIDIES*/




EQUATION("TotalSubsidies")
/*
Calcul du total des subventions publiques allouées à différents secteurs.
*/

// Subventions par secteur
v[0] = V("SubsidiesAg");     // Subventions pour l'agriculture
v[1] = V("SubsidiesEner");   // Subventions pour l'énergie
v[2] = V("SubsidiesTrans");  // Subventions pour le transport
v[3] = V("SubsidiesHous");   // Subventions pour le logement
v[4] = V("SubsidiesInd");    // Subventions pour l'industrie
v[5] = V("SubsidiesTC");     // Subventions pour la technologie et communication

// Calcul du total des subventions
v[6] = v[0] + v[1] + v[2] + v[3] + v[4] + v[5];

RESULT(v[6])


EQUATION("SubsidiesAg")
/*
Calcul du total des subventions pour le secteur de l'agriculture.
Somme des subventions individuelles allouées aux agents dans ce secteur.
*/
v[0] = SUM("SubsidyAg");
RESULT(v[0])


EQUATION("SubsidiesEner")
/*
Calcul du total des subventions pour le secteur de l'énergie.
Somme des subventions individuelles allouées aux agents dans ce secteur.
*/
v[0] = SUM("SubsidyEner");
RESULT(v[0])


EQUATION("SubsidiesTrans")
/*
Calcul du total des subventions pour le secteur du transport.
Somme des subventions individuelles allouées aux agents dans ce secteur.
*/
v[0] = SUM("SubsidyTrans");
RESULT(v[0])


EQUATION("SubsidiesHous")
/*
Calcul du total des subventions pour le secteur du logement.
Somme des subventions individuelles allouées aux agents dans ce secteur.
*/
v[0] = SUM("SubsidyHous");
RESULT(v[0])


EQUATION("SubsidiesInd")
/*
Calcul du total des subventions pour le secteur de l'industrie.
Somme des subventions individuelles allouées aux agents dans ce secteur.
*/
v[0] = SUM("SubsidyInd");
RESULT(v[0])


EQUATION("SubsidiesTC")
/*
Calcul du total des subventions pour le secteur de la technologie et de la communication.
Somme des subventions individuelles allouées aux agents dans ce secteur.
*/
v[0] = SUM("SubsidyTC");
RESULT(v[0])



/*PUBLIC INVESTMENTS*/
/*PUBLIC INVESTMENTS*/



EQUATION("PublicInvestmentAg")
/*
Calcul du total des investissements publics pour le secteur de l'agriculture. Somme des investissements individuels alloués dans ce secteur.
*/

v[0] = SUM("PubInvestmentAg");  // Somme des investissements dans le secteur agricole

RESULT(v[0])


EQUATION("PublicInvestmentEner")

/* Calcul du total des investissements publics pour le secteur de l'énergie. Somme des investissements individuels alloués dans ce secteur. */

v[0] = SUM("PubInvestmentEner");  // Somme des investissements dans le secteur énergétique

RESULT(v[0])


EQUATION("PublicInvestmentTrans")

/* Calcul du total des investissements publics pour le secteur des transports. Somme des investissements individuels alloués dans ce secteur. */

v[0] = SUM("PubInvestmentTrans");  // Somme des investissements dans le secteur des transports

RESULT(v[0])


EQUATION("PublicInvestmentHous")

/* Calcul du total des investissements publics pour le secteur du logement. Somme des investissements individuels alloués dans ce secteur. */

v[0] = SUM("PubInvestmentHous");  // Somme des investissements dans le secteur du logement

RESULT(v[0])



EQUATION("PublicInvestmentInd")

/* Calcul du total des investissements publics pour le secteur industriel. Somme des investissements individuels alloués dans ce secteur. */

v[0] = SUM("PubInvestmentInd");  // Somme des investissements dans le secteur industriel

RESULT(v[0])


EQUATION("PublicInvestmentTC")

/* Calcul du total des investissements publics pour le secteur des technologies et communications. Somme des investissements individuels alloués dans ce secteur. */

v[0] = SUM("PubInvestmentTC");  // Somme des investissements dans le secteur des technologies et communications

RESULT(v[0])








/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 
/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 
/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 
/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 
/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 
/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 
/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 
/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 
/*MENAGES ELECTEURS ET CONSOMMATEURS*/ 




EQUATION("NeedsIndex")
/*
Comment
*/

v[0] = VL("NeedsIndex", 1);
v[1] = V("GrNeedsIndex");

v[2] = v[0] * (1 + v[1]);

RESULT( v[2])



EQUATION("GrNeedsIndex")
/*
Comment
Mean Disposable Income or Minimum Wage?
*/

v[0] = V("hum0");
v[1] = V("hum1");
v[2] = V("hum2");
v[3] = V("hum3");
v[4] = V("BaseConsumption");
v[5] = V("DisposableIncome");
v[6] = V("MeanDisposableIncome");
v[7] = V("PublicServicesAccess");
v[8] = V("hum4");
v[9] = V("Recognition");

v[10] = v[0] * (1 - (v[4] / v[5])) + v[1] * (v[5] / v[6]) + v[2] * v[7];

RESULT( v[10])


EQUATION("Recognition")
/*
This equation captures the political effect of austerity versus redistributive policies. It follows the findings on austerity and populism since the 2010's.
*/

v[0] = V("StabVarRecognition");
v[1] = V("Taxes");
v[2] = V("Red");

v[3] = v[0] * (v[2] - v[1]);

RESULT( v[3])



EQUATION("PublicServiceAccess")
/*
Comment
*/

v[0] = V("GenParPubSerAccess");
v[1] = V("PubSpendPubServ");
v[2] = V("Spatial Justice");

v[3] = v[0] * v[1] * v[2];

RESULT( v[3])


EQUATION("Spatial Justice")
/*
Comment
*/

v[0] = V("StabPar");
v[1] = V("ConsTrans");
v[2] = V("DisposableIncome");
v[4] = V("Red");
v[5] = V("Par2");
v[7] = V("GeneralParSpatialJustice");

v[6] = v[7] * (v[0] * (v[1]/v[2]) + v[5] * v[4]);

RESULT( v[6])



EQUATION("VoteDecision")
/*
Calcul de la décision de vote en fonction de l'évolution du NeedsIndex, du bandwagon effect, et de l'inertie liée au vote précédent.
*/

v[0] = V("NeedsIndex");          // Indice de satisfaction des besoins actuel
v[1] = VL("NeedsIndex", 1);      // Indice de satisfaction des besoins à la période précédente
v[2] = V("BandwagonEffect");     // Proportion d'agents ayant voté anti-transition à la période précédente
v[3] = VL("VoteDecision", 1);    // Vote de l'agent à la période précédente (1 = anti-transition, 0 = pro-transition)

// Pondérations des facteurs influençant la probabilité de voter anti-transition
v[4] = 0.5;                      // Pondération de l'évolution des besoins
v[5] = 0.3;                      // Pondération de l'effet de groupe (bandwagon)
v[6] = 0.2;                      // Pondération de l'inertie liée au vote précédent

// Calcul de la probabilité de voter anti-transition
v[7] = v[4] * (v[0] - v[1]);    // Contribution de l'évolution des besoins
v[7] = v[7] + v[5] * v[2];      // Ajout de l'effet bandwagon
v[7] = v[7] + v[6] * v[3];      // Ajout de l'inertie

// Limiter la probabilité de voter anti-transition à [0, 1] sans utiliser MIN et MAX
if (v[7] < 0) {
    v[7] = 0;  // Si v[7] est inférieur à 0, on le limite à 0
} else if (v[7] > 1) {
    v[7] = 1;  // Si v[7] est supérieur à 1, on le limite à 1
}

// Décision de vote : 1 = anti-transition, 0 = pro-transition
if (RND < v[7]) {
    v[8] = 1; // Vote anti-transition
} else {
    v[8] = 0; // Vote pro-transition
}

RESULT(v[8])




EQUATION("Income")
/*
Calcul du revenu individuel des ménages en fonction de leur statut d'emploi et de leur employeur.
- Status = 0 : Allocation chômage (UnemploymentBenefit)
- Status = 1 : Salaire brun peu qualifié (LowSkilledBrownWage de la firme IdFirm)
- Status = 2 : Salaire vert peu qualifié (LowSkilledGreenWage de la firme IdFirm)
- Status = 3 : Salaire minimum (MinimumWage)
- Status = 4 : Allocation chômage (UnemploymentBenefit)
- Status = 5 : Salaire brun hautement qualifié (HighSkilledBrownWage de la firme IdFirm)
- Status = 6 : Salaire vert hautement qualifié (HighSkilledGreenWage de la firme IdFirm)
*/

v[0] = V("Status");  // Récupération du statut du ménage
v[2] = V("IdFirm");  // Récupération de l'identifiant de la firme

if (v[0] == 0 || v[0] == 4) {  
    v[1] = V("UnemploymentBenefit");  // Allocation chômage
} else if (v[0] == 3) {  
    v[1] = V("MinimumWage");  // Salaire minimum
} else {  
    CYCLE(cur, "Firms")  // Parcours de toutes les firmes
        if (VLS(cur, "IdFirm", 1) == v[2]) {  // Vérifie si la firme correspond à IdFirm
            if (v[0] == 1) {  
                v[1] = VS(cur, "LowSkilledBrownWage");  
            } else if (v[0] == 2) {  
                v[1] = VS(cur, "LowSkilledGreenWage");  
            } else if (v[0] == 5) {  
                v[1] = VS(cur, "HighSkilledBrownWage");  
            } else if (v[0] == 6) {  
                v[1] = VS(cur, "HighSkilledGreenWage");  
            } else {  
                v[1] = 0;  // Cas par défaut si Status est inconnu
            }
            break;  // On sort du CYCLE dès qu'on a trouvé la bonne firme
        }
}

RESULT(v[1])  // Retourne le revenu individuel du ménage



EQUATION("DisposableIncome")
/*
Calcul du revenu disponible des ménages.
Les ressources comprennent :
- Revenu du travail ou des allocations (Income)
- Revenu financier (FinancialIncome)
- Transferts reçus (Red)

Les sorties comprennent :
- Impôts payés (Taxes)
- Service de la dette des ménages (HouseholdDebtService)
*/

v[0] = V("Income");               // Revenu du ménage (travail ou allocations)
v[1] = V("FinancialIncome");      // Revenu financier
v[2] = V("Red");                  // Transferts reçus
v[3] = V("Taxes");                // Impôts payés
v[4] = V("HouseholdDebtService"); // Service de la dette

// Calcul du revenu disponible : ressources - sorties
v[5] = (v[0] + v[1] + v[2]) - (v[3] + v[4]);

RESULT(v[5])  // Retourne le revenu disponible du ménage


EQUATION("HouseholdDebtService")
/*
Calcul du service de la dette des ménages.
Le service de la dette correspond aux intérêts payés sur la dette totale des ménages.
Il est calculé comme le produit de la dette totale des ménages (HouseholdTotalDebt, valeur lag) par le taux d'intérêt sur les crédits à la consommation (LoanRateCons).
*/

v[0] = VL("HouseholdTotalDebt", 1); // Dette totale des ménages (valeur lag de 1)
v[1] = V("LoanRateCons");           // Taux d'intérêt sur les crédits à la consommation

RESULT(v[0] * v[1])  // Retourne le service de la dette



EQUATION("Consumption")
/*
Modélisation de la consommation des ménages.
Les ménages consomment en fonction de leur revenu disponible, de leur épargne et de leur capacité d'endettement.

- BaseConsumption : consommation minimale incompressible.
- Si DisposableIncome + Savings (VL 1) > BaseConsumption, le ménage consomme un montant supplémentaire (AdditionalConsumption).
- Si BaseConsumption > DisposableIncome + Savings (VL 1), le ménage s'endette (HouseholdDebt) pour régler BaseConsumption, sans consommer au-delà.
- La valeur de HouseholdDebt doit être ajoutée à HouseholdTotalDebt.
*/

v[0] = V("BaseConsumption");      // Consommation de base incompressible
v[1] = V("DisposableIncome");     // Revenu disponible du ménage
v[2] = VL("Savings", 1);          // Épargne du ménage (valeur lag)
v[3] = V("PropensityToConsumeDI"); // Propension à consommer le revenu disponible
v[4] = V("PropensityToConsumeSavings"); // Propension à consommer l'épargne
v[5] = V("HouseholdDebt");        // Endettement du ménage
v[6] = V("HouseholdTotalDebt");   // Dette totale du ménage

v[7] = v[1] + v[2];  // Ressources disponibles (revenu + épargne)

if (v[7] >= v[0]) {  
    // Le ménage peut consommer au-delà de sa consommation de base
    v[8] = v[0] + v[3] * v[1] + v[4] * v[2];
} else {  
    // Le ménage ne peut pas couvrir BaseConsumption avec ses ressources, il s'endette
    v[8] = v[0];  
    v[6] += v[5]; // Ajout de HouseholdDebt à HouseholdTotalDebt
    WRITE("HouseholdTotalDebt", v[6]); // Mise à jour de la dette totale
}

RESULT(v[8])  // Retourne la consommation totale du ménage



EQUATION("FinancialIncome")
/*
Financial income (interest on deposits)
*/

v[0] = V("DepositInterestRate");
v[1] = VL("Savings", 1);

v[2] = v[0]*v[1];

RESULT( v[2])


EQUATION("Savings")
/*
Deposits
*/

v[0] = V("DisposableIncome");
v[1] = V("Consumption");
v[2] = VL("Savings", 1);

v[3] = v[2] + (v[0] - v[1]);

RESULT( v[3])


EQUATION("FinPosHH")
/*
Revenu disponible
*/

v[0] = V("Yfin");
v[1] = VL("TotalDebt", 1);
v[2] = V("ConsumerCreditRisk");

v[3] = v[0] - (v[1] * v[2]);

RESULT( v[3])


EQUATION("TotalDebt")
/*
Total Debt of households
*/

v[0] = VL("LoanCons", 1);
v[1] = V("LoanCons");

v[2] = v[0] + v[1];

RESULT( v[2])



/*
EQUATION("ValDesCons")


v[0]= V("Ydisp");
v[1]= V("alpha0");
v[2]= V("alpha1");
v[3]= VL("S", 1);

if(V("IrreducibleCons")>(V("Ydisp")+VL("S", 1)))
{
v[4] = V("IrreducibleCons"); // Consumption rationing
}
else
{
v[4] = v[1]*v[0]+v[2]*v[3];
}
RESULT(v[4])
*/


EQUATION("ConsAg")
/*
Monetary value of irreducible food consumption
*/

v[0] = VL("ConsAg", 1);
v[1] = V("PriceAg");
v[2] = VL("PriceAg", 1);

v[3] = v[0]*(1+(v[1]-v[2]));

RESULT( v[3])


EQUATION("ConsEner")
/*
Monetary value of irreducible energy consumption
*/

v[0] = VL("ConsEner", 1);
v[1] = V("PriceEner");
v[2] = VL("PriceEner", 1);

v[3] = v[0]*(1+(v[1]-v[2]));

RESULT( v[3])


EQUATION("ConsHous")
/*
Monetary value of irreducible housing consumption
*/

v[0] = VL("ConsHous", 1);
v[1] = V("PriceHous");
v[2] = VL("PriceHous", 1);

v[3] = v[0]*(1+(v[1]-v[2]));

RESULT( v[3])


EQUATION("ConsTrans")
/*
Monetary value of irreducible transportation consumption
*/

v[0] = VL("ConsTrans", 1);
v[1] = V("PriceTrans");
v[2] = VL("PriceTrans", 1);

v[3] = v[0]*(1+(v[1]-v[2]));

RESULT( v[3])


EQUATION("BaseCons")
/*
Base consumption.
*/

v[0] = V("ConsAg");
v[1] = V("ConsEner");
v[2] = V("ConsHous");
v[3] = V("ConsTrans");

v[4] = v[0] + v[1] + v[2] + v[3];

RESULT(v[4])


EQUATION("SuppCons")
/*
Consumption supplementary to irreducible consumption
*/

v[0] = V("ValDesCons");
v[1] = V("IrreducibleCons");

v[2] = v[0] - v[1];

RESULT( v[2])


EQUATION("SuppConsAg")
/*
Comment
*/

v[0] = V("AgPref");
v[1] = V("SuppCons");

v[2] = v[0] * v[1];

RESULT( v[2])

EQUATION("SuppConsEner")
/*
Comment
*/

v[0] = V("EnerPref");
v[1] = V("SuppCons");

v[2] = v[0]*v[1];

RESULT( v[2])

EQUATION("SuppConsHous")
/*
Comment
*/

v[0] = V("HousPref");
v[1] = V("SuppCons");

v[2] = v[0]*v[1];

RESULT( v[2])

EQUATION("SuppConsTrans")
/*
Comment
*/

v[0] = V("TransPref");
v[1] = V("SuppCons");

v[2] = v[0]*v[1];

RESULT( v[2])

EQUATION("SuppConsInd")
/*
Comment
*/

v[0] = V("IndPref");
v[1] = V("SuppCons");

v[2] = v[0]*v[1];

RESULT( v[2])

EQUATION("SuppConsTC")
/*
Comment
*/

v[0] = V("TCPref");
v[1] = V("SuppCons");

v[2] = v[0]*v[1];

RESULT( v[2])


EQUATION("NormalizePreferences")
/*
Équation qui normalise les préférences de manière à ce que leur somme soit égale à 1.
*/

v[0] = V("AgPref");
v[1] = V("EnerPref");
v[2] = V("HousPref");
v[3] = V("TransPref");
v[4] = V("IndPref");
v[5] = V("TCPref");

// Calcul de la somme des préférences
v[6] = v[0] + v[1] + v[2] + v[3] + v[4] + v[5];

// Calcul de l'écart par rapport à 1
v[7] = 1.0 - v[6];

// Ajustement des préférences pour que la somme soit égale à 1
WRITE("AgPref", v[0] + v[7] * (v[0] / v[6]));  // Ajuster AgPref
WRITE("EnerPref", v[1] + v[7] * (v[1] / v[6]));  // Ajuster EnerPref
WRITE("HousPref", v[2] + v[7] * (v[2] / v[6]));  // Ajuster HousPref
WRITE("TransPref", v[3] + v[7] * (v[3] / v[6]));  // Ajuster TransPref
WRITE("IndPref", v[4] + v[7] * (v[4] / v[6]));  // Ajuster IndPref
WRITE("TCPref", v[5] + v[7] * (v[5] / v[6]));  // Ajuster TCPref

RESULT(0)




EQUATION("ConsAgTot")
/*
Comment
*/

v[0] = V("ConsAg");
v[1] = V("SuppConsAg");

v[2] = v[0] + v[1];

RESULT( v[2])

EQUATION("ConsEnerTot")
/*
Comment
*/

v[0] = V("ConsEner");
v[1] = V("SuppConsEner");

v[2] = v[0] + v[1];

RESULT( v[2])

EQUATION("ConsHousTot")
/*
Comment
*/

v[0] = V("ConsHous");
v[1] = V("SuppConsHous");

v[2] = v[0] + v[1];

RESULT( v[2])

EQUATION("ConsTransTot")
/*
Comment
*/

v[0] = V("ConsTrans");
v[1] = V("SuppConsTrans");

v[2] = v[0] + v[1];

RESULT( v[2])

EQUATION("ConsIndTot")
/*
Comment
*/

v[0] = V("ConsInd");
v[1] = V("SuppConsInd");

v[2] = v[0] + v[1];

RESULT( v[2])

EQUATION("ConsTCTot")
/*
Comment
*/

v[0] = V("ConsTC");
v[1] = V("SuppConsTC");

v[2] = v[0] + v[1];

RESULT( v[2])

/*

EQUATION("ConsPref")



v[40]=VS(c,"AgPref");
v[41]=VS(c,"EnerPref");
v[42]=VS(c,"HousPref");
v[43]=VS(c,"TransPref");
v[44]=VS(c,"IndPref");
v[45]=VS(c,"TCPref");

v[46]=v[40]+v[41]+v[42]+v[43]+v[44]+v[45];
v[0]=v[40]/v[46];
v[1]=v[41]/v[46];
v[2]=v[42]/v[46];
v[3]=v[43]/v[46];
v[4]=v[44]/v[46];
v[5]=v[45]/v[46];

RESULT( )

Comment
*/

/*
Once the monetary value of consumption is determined, we can identify how households are going to allocate money between sectors, firms, and goods.
*/






EQUATION("ProdUsed") 
/*
D?termine le produit utilis? par le client
*/

V("InitTrade"); 
v[0]=VL("ProdUsed",1);
v[2]=V("Rebuy");
  if(v[2]==1)
  	v[3]=v[0];// garde le meme produit
  else
  	v[3]=V("Purchase"); //achat d'un nouveau produit
  
RESULT(v[3])



FUNCTION("Rebuy")
/*
Determine si le client garde le meme fournisseur : 1=oui, 0=non
*/
if(t==1)// pour la 1ere periode : pas de rachat possible
{
END_EQUATION(0);
}

v[30]=VS(c,"a");
v[31]=VS(c,"b");
v[32]=VS(c,"c");
v[33]=VS(c,"d");
v[34]=v[30]+v[31]+v[32]+v[33];
v[0]=v[30]/v[34];// pour que la somme des pref fasse 1
v[1]=v[31]/v[34];
v[2]=v[32]/v[34];
v[3]=v[33]/v[34];

v[4]=VLS(c,"ProdUsed",1);
v[5]=VS(c,"Product_Type");
v[22]=VS(c,"Alpha_Regu_Households");


if(v[4]==0)//si le client n'a pas de produit : pas de rachat possible
END_EQUATION(0);


CYCLE(cur, "Firm")// verifie que la firme n'a pas disparu
 {
  v[20]=VS(cur,"IdFirm");
  if(v[4]==v[20])
  {
  	v[21]=VS(cur,"Dead");
  	if(v[21]==1)
  	END_EQUATION(0);
  }
 }


v[12]=0;// le resultat fait 0 par defaut

CYCLE(cur, "Firm")
{
  v[6]=VS(cur,"IdFirm");

  if(v[6]==v[4])
  {
  CYCLES(cur, cur1, "Product")
   {
     v[7]=VS(cur1,"IdProduct");

      if(v[7]==v[5])
    {
    	v[15]=VS(cur1,"IsAdopted");
    
    	if(v[15]==0)// si le produit n'est plus commercialise
    	{
    	END_EQUATION(0);
    	}
    	
    	v[8]=UNIFORM(0,1);
    		
    	if(v[8]<=v[0])//on cherche la dimension a retenir en fonction des preferences du client
    	{
    			v[9]=VL("Max_X",1);
    			v[10]=VS(cur1,"X");
    			v[11]=UNIFORM(0.8,1.2);//terme d'erreur
    			if(v[10]>=(v[9]*v[11]))//garde le meme fournisseur
    			{
    				v[27]=VS(cur,"Portfolio");
    				if(v[27]==0)//si la firme n'a pas la technologie 2 dans son portefeuille
    				{
    					v[23]=V("Sunset_Date");
    					v[24]=V("Revision_Period");
    					v[25]=v[22]*t/(v[23]+v[24]);//proba de defection
    					v[26]=UNIFORM(0,1);
    
    					if(v[26]<=v[25])//si tirage de defection reussi
    					END_EQUATION(0);
    				}
    			
       	v[12]=1;// il garde le meme produit
    				INCRS(cur,"Sales",1);// La firme enregistre une vente en plus 
     			INCRS(cur1,"Sales_Prod",1);// augmente les ventes du produit de 1
    			}
    	}
    
    	if(v[8]>v[0]&&v[8]<=(v[0]+v[1]))
    	{
    		v[9]=VL("Min_Price",1);
    		v[10]=VLS(cur1,"Price",1);
    		v[11]=UNIFORM(0.8,1.2);//terme d'erreur
    		if(v[10]<=(v[9]*v[11]))//garde le meme fournisseur
    			{
    				v[27]=VS(cur,"Portfolio");
    				if(v[27]==0)//si la firme n'a pas la technologie 2 dans son portefeuille
    				{
    					v[23]=V("Sunset_Date");
    					v[24]=V("Revision_Period");
    					v[25]=v[22]*t/(v[23]+v[24]);//proba de defection
    					v[26]=UNIFORM(0,1);
    
    					if(v[26]<=v[25])//si tirage de defection reussi
    					END_EQUATION(0);
    				}
    			
       	v[12]=1;// il garde le meme produit
    				INCRS(cur,"Sales",1);// La firme enregistre une vente en plus (REPLACE PAR ConsAg/Price)
     			INCRS(cur1,"Sales_Prod",1);// augmente les ventes du produit de 1
    			}
    	}
    
    	if(v[8]>(v[0]+v[1])&&v[8]<=(v[0]+v[1]+v[2]))
    	{
    		v[9]=VL("Min_Tox",1);
    		v[10]=VS(cur1,"Tox");
    		v[11]=UNIFORM(0.8,1.2);//terme d'erreur
    		if(v[10]<=(v[9]*v[11]))//garde le meme fournisseur
    			{
    				v[27]=VS(cur,"Portfolio");
    				if(v[27]==0)//si la firme n'a pas la technologie 2 dans son portefeuille
    				{
    					v[23]=V("Sunset_Date");
    					v[24]=V("Revision_Period");
    					v[25]=v[22]*t/(v[23]+v[24]);//proba de defection
    					v[26]=UNIFORM(0,1);
    
    					if(v[26]<=v[25])//si tirage de defection reussi
    					END_EQUATION(0);
    				}
    			
       	v[12]=1;// il garde le meme produit
    				INCRS(cur,"Sales",1);// La firme enregistre une vente en plus 
     			INCRS(cur1,"Sales_Prod",1);// augmente les ventes du produit de 1
    			}
    	}
    
    	if(v[8]>(v[0]+v[1]+v[2]))
    	{
    			v[9]=VL("Min_Bio",1);
    			v[10]=VS(cur1,"Bio");
    			v[11]=UNIFORM(0.8,1.2);//terme d'erreur
    			if(v[10]<=(v[9]*v[11]))//garde le meme fournisseur
    			{
    				v[27]=VS(cur,"Portfolio");
    				if(v[27]==0)//si la firme n'a pas la technologie 2 dans son portefeuille
    				{
    					v[23]=V("Sunset_Date");
    					v[24]=V("Revision_Period");
    					v[25]=v[22]*t/(v[23]+v[24]);//proba de defection
    					v[26]=UNIFORM(0,1);
    
    					if(v[26]<=v[25])//si tirage de defection reussi
    					END_EQUATION(0);
    				}
    			
       	v[12]=1;// il garde le meme produit
    				INCRS(cur,"Sales",1);// La firme enregistre une vente en plus 
     			INCRS(cur1,"Sales_Prod",1);// augmente les ventes du produit de 1
    			}
    	}
   }
  }
 }
}   
    
RESULT( v[12])





FUNCTION("Purchase")
/*
Fonction correspondant au processus d'achat du client
*/
v[40]=VS(c,"a");
v[41]=VS(c,"b");
v[42]=VS(c,"c");
v[43]=VS(c,"d");
v[44]=v[40]+v[41]+v[42]+v[43];
v[0]=v[40]/v[44];// pour que la somme des pref fasse 1
v[1]=v[41]/v[44];
v[2]=v[42]/v[44];
v[3]=v[43]/v[44];
v[4]=VS(c,"e");
v[30]=VS(c,"Reservation_Price");
v[31]=VS(c,"Reservation_X");
v[34]=VS(c,"Alpha_Regu_Households");
v[22]=V("A");//pour X
v[23]=V("B");//pour Price
v[24]=V("C");//pour Tox
v[25]=V("D");//pour Bio
v[35]=V("Sunset_Date");
v[36]=V("Revision_Period");

v[18]=UNIFORM(0,0.1);//alea pour eviter pb de MS=0 => U=0

v[27]=0;

v[8]=UNIFORM(0,1);

if(v[8]<=v[0])//on cherche la dimension a retenir en fonction des preferences du client
{
CYCLE(cur, "Product_Purchase")// calcul l'utilite de chaque produit en retenant que X
 {
  v[5]=VS(cur,"Purchase_X");
	v[6]=VS(cur,"Purchase_Price");
  v[9]=VS(cur,"Purchase_MS");
  v[17]=VS(cur,"Purchase_IsAdopted");
  v[33]=VS(cur,"Purchase_Portfolio");
  v[50]=V("Error");//pour terme d'erreur !!!!!!
  v[51]=UNIFORM(1-v[50],1+v[50]);//terme d'erreur !!!!!

 
	if(v[6]>v[30]||v[5]<v[31])//si prix sup au prix de reserve et la perf X inf au seuil min
	v[10]=0;// ut = 0
 	else
 	{
 		if(v[33]==0)//si la firme n'a pas la technologie 2 dans son portefeuille
 		v[10]=(1-v[34]*t/(v[35]+v[36]))*(v[17]*(v[5]*v[51]-v[22])*pow(v[9]+v[18],v[4]));//!!!!
 		else
  		v[10]=v[17]*(v[5]*v[51]-v[22])*pow(v[9]+v[18],v[4]);//!!!!!
  }
  WRITES(cur,"Utility",v[10]);
	v[27]=v[27]+v[10];
 }
}

if(v[8]>v[0]&&v[8]<=(v[0]+v[1]))
{
CYCLE(cur, "Product_Purchase")// calcul l'utilite de chaque produit en retenant que Price
 {
  v[5]=VS(cur,"Purchase_X");
	v[6]=VS(cur,"Purchase_Price");
  v[9]=VS(cur,"Purchase_MS");
  v[17]=VS(cur,"Purchase_IsAdopted");
  v[33]=VS(cur,"Purchase_Portfolio");
  v[50]=V("Error");//pour terme d'erreur !!!!!!
  v[51]=UNIFORM(1-v[50],1+v[50]);//terme d'erreur !!!!!

 
	if(v[6]>v[30]||v[5]<v[31])//si prix sup au prix de reserve et la perf X inf au seuil min
	v[10]=0;// ut = 0
 	else
 	{
 		if(v[33]==0)//si la firme n'a pas la technologie 2 dans son portefeuille
 		v[10]=(1-v[34]*t/(v[35]+v[36]))*(v[17]*(v[23]-v[6]*v[51])*pow(v[9]+v[18],v[4]));//!!!!!
 		else
  		v[10]=v[17]*(v[23]-v[6]*v[51])*pow(v[9]+v[18],v[4]);//!!!!!
  }
  WRITES(cur,"Utility",v[10]);
	v[27]=v[27]+v[10];
 }
}

if(v[8]>(v[0]+v[1])&&v[8]<=(v[0]+v[1]+v[2]))
{
CYCLE(cur, "Product_Purchase")// calcul l'utilite de chaque produit en retenant que Tox
 {
  v[5]=VS(cur,"Purchase_X");
	v[6]=VS(cur,"Purchase_Price");
	v[7]=VS(cur,"Purchase_Tox");
  v[9]=VS(cur,"Purchase_MS");
  v[17]=VS(cur,"Purchase_IsAdopted");
  v[33]=VS(cur,"Purchase_Portfolio");
  v[50]=V("Error");//pour terme d'erreur !!!!!!
  v[51]=UNIFORM(1-v[50],1+v[50]);//terme d'erreur !!!!!

 
	if(v[6]>v[30]||v[5]<v[31])//si prix sup au prix de reserve et la perf X inf au seuil min
	v[10]=0;// ut = 0
 	else
 	{
 		if(v[33]==0)//si la firme n'a pas la technologie 2 dans son portefeuille
 		v[10]=(1-v[34]*t/(v[35]+v[36]))*(v[17]*(v[24]-v[7]*v[51])*pow(v[9]+v[18],v[4]));//!!!!!
 		else
  		v[10]=v[17]*(v[24]-v[7]*v[51])*pow(v[9]+v[18],v[4]);//!!!!!!
  }
  WRITES(cur,"Utility",v[10]);
	v[27]=v[27]+v[10];
 }
}

if(v[8]>(v[0]+v[1]+v[2]))
{
CYCLE(cur, "Product_Purchase")// calcul l'utilite de chaque produit en retenant que Bio
 {
  v[5]=VS(cur,"Purchase_X");
	v[6]=VS(cur,"Purchase_Price");
	v[7]=VS(cur,"Purchase_Bio");
  v[9]=VS(cur,"Purchase_MS");
  v[17]=VS(cur,"Purchase_IsAdopted");
  v[33]=VS(cur,"Purchase_Portfolio");
  v[50]=V("Error");//pour terme d'erreur !!!!!!
  v[51]=UNIFORM(1-v[50],1+v[50]);//terme d'erreur !!!!!

 
	if(v[6]>v[30]||v[5]<v[31])//si prix sup au prix de reserve et la perf X inf au seuil min
	v[10]=0;// ut = 0
 	else
 	{
 		if(v[33]==0)//si la firme n'a pas la technologie 2 dans son portefeuille
 		v[10]=(1-v[34]*t/(v[35]+v[36]))*(v[17]*(v[25]-v[7]*v[51])*pow(v[9]+v[18],v[4]));//!!!!!!
 		else
  		v[10]=v[17]*(v[25]-v[7]*v[51])*pow(v[9]+v[18],v[4]);//!!!!!!
  }
  WRITES(cur,"Utility",v[10]);
	v[27]=v[27]+v[10];
 }
}


if(v[27]==0)//si les utilites sont toutes nulles
{
	WRITES(c,"Product_Type",0);// inscrit le type de produit achete dans l'objet Household
	END_EQUATION(0);
}

cur=RNDDRAW("Product_Purchase","Utility");//choisit le produit avec tirage aleatoire proportionnel aux utilites

v[11]=VS(cur,"IdFirm_Purchase");// recupere l'identifiant de la firme choisie
v[12]=VS(cur,"IdProduct_Purchase");// recupere le type de produit choisi
WRITES(c,"Product_Type",v[12]);// inscrit le type de produit achete dans l'objet Household


CYCLE(cur1, "Firm")
{

	v[13]=VS(cur1,"IdFirm");

	if(v[13]==v[11])//repere la firme selectionnee
 	{
 		INCRS(cur1,"Sales",1);// augmente les vente de la firme selectionnee d'une unite
  	CYCLES(cur1, cur2, "Product")
   	{
   		v[14]=VS(cur2,"IdProduct");
  			if(v[14]==v[12])
   			{
   				INCRS(cur2,"Sales_Prod",1);// augmente les ventes du produit de 1
    				
   			}
   		}
 	}
}


RESULT(v[11] )// retourne l'identifiant de la firme selectionnee




/*
LABOUR MARKET
*/






EQUATION("Firm_BrownDemand")
/*
Cette équation calcule la demande d'emplois bruns pour une entreprise,
avec un arrondi pour obtenir un nombre entier d'emplois.
*/

CYCLE(cur, "Firms") {
    // Récupérer la production de la firme (production de biens ou services bruns)
    v[0] = VS(cur, "ProductionBrown");  // Production de l'entreprise dans le secteur brun

    // Récupérer la productivité des employés dans ce secteur
    v[1] = VS(cur, "BrownProductivity");  // Productivité des employés dans le secteur brun

    // Calcul de la demande d'emplois bruns : la production divisée par la productivité des employés
    v[2] = v[0] / v[1];  // Demande d'emplois bruns

    // Arrondi du résultat pour obtenir un entier
    //v[2] = ROUND(v[2]);  // Arrondir à l'entier le plus proche

    // Résultat : nombre d'emplois bruns demandés
    RESULT(v[2]);
}


EQUATION("Firm_GreenDemand")
/*
Cette équation calcule la demande d'emplois verts pour une entreprise,
avec un arrondi pour obtenir un nombre entier d'emplois.
*/

CYCLE(cur, "Firms") {
    // Récupérer la production de la firme dans le secteur vert
    v[0] = VS(cur, "ProductionGreen");  // Production de l'entreprise dans le secteur vert

    // Récupérer la productivité des employés dans le secteur vert
    v[1] = VS(cur, "GreenProductivity");  // Productivité des employés dans le secteur vert

    // Calcul de la demande d'emplois verts : la production divisée par la productivité des employés
    v[2] = v[0] / v[1];  // Demande d'emplois verts

    // Arrondi du résultat pour obtenir un entier
    //v[2] = ROUND(v[2]);  // Arrondir à l'entier le plus proche

    // Résultat : nombre d'emplois verts demandés
    RESULT(v[2]);
}



EQUATION("Status") 
/* Mise à jour du statut d'emploi des ménages avec les nouveaux types de salaires et les qualifications. */
v[0] = VL("Status", 1); // Statut de l'emploi du ménage à la période précédente
v[1] = V("IdHousehold"); // Identifiant du ménage
v[2] = V("IdFirm"); // Identifiant de l'entreprise à t-1
v[3] = V("SkillStatus"); // Statut de qualification du ménage (0 = basse qualification, 1 = haute qualification)
v[4] = V("TransitionActive"); // Variable déterminant si la transition vers un emploi garanti par l'État est active (1 = oui, 0 = non)
v[5] = V("ReskillingCounter"); // Compteur pour suivre les années de reskilling

// Récupération des salaires proposés par l'entreprise et des demandes détaillées
CYCLE(cur, "Firms") {
    if (v[2] == VS(cur, "IDFirm")) { // Vérification si c'est la bonne entreprise
        v[10] = VS(cur, "BrownLowSkilledWage"); // Salaire bas pour les emplois bruns non qualifiés
        v[11] = VS(cur, "BrownHighSkilledWage"); // Salaire élevé pour les emplois bruns qualifiés
        v[12] = VS(cur, "GreenLowSkilledWage"); // Salaire bas pour les emplois verts non qualifiés
        v[13] = VS(cur, "GreenHighSkilledWage"); // Salaire élevé pour les emplois verts qualifiés
        v[14] = VS(cur, "Firm_BrownLowSkilledDemand"); // Demande d'emplois bruns non qualifiés à t-1
        v[15] = VS(cur, "Firm_BrownHighSkilledDemand"); // Demande d'emplois bruns qualifiés à t-1
        v[16] = VS(cur, "Firm_GreenLowSkilledDemand"); // Demande d'emplois verts non qualifiés à t-1
        v[17] = VS(cur, "Firm_GreenHighSkilledDemand"); // Demande d'emplois verts qualifiés à t-1
    }
}
v[18] = V("Firm_BrownLowSkilledDemand"); // Demande d'emplois bruns non qualifiés à t
v[19] = V("Firm_BrownHighSkilledDemand"); // Demande d'emplois bruns qualifiés à t
v[20] = V("Firm_GreenLowSkilledDemand"); // Demande d'emplois verts non qualifiés à t
v[21] = V("Firm_GreenHighSkilledDemand"); // Demande d'emplois verts qualifiés à t

// Calcul des postes à pourvoir ou à réduire
v[22] = max(0, v[18] - v[14]); // Postes bruns non qualifiés disponibles
v[23] = max(0, v[19] - v[15]); // Postes bruns qualifiés disponibles
v[24] = max(0, v[20] - v[16]); // Postes verts non qualifiés disponibles
v[25] = max(0, v[21] - v[17]); // Postes verts qualifiés disponibles
v[26] = max(0, v[14] - v[18]); // Licenciements bruns non qualifiés nécessaires
v[27] = max(0, v[15] - v[19]); // Licenciements bruns qualifiés nécessaires
v[28] = max(0, v[16] - v[20]); // Licenciements verts non qualifiés nécessaires
v[29] = max(0, v[17] - v[21]); // Licenciements verts qualifiés nécessaires

// Si le ménage est en reskilling, il prend le statut 5 pendant deux ans
if (v[0] == 5) {
    v[5] += 1; // Incrémente le compteur de reskilling
    if (v[5] >= 2) {
        v[0] = 0; // Après deux ans, le ménage redevient chômeur
        v[5] = 0; // Réinitialiser le compteur de reskilling
    }
} else {
    // Si le ménage est au chômage et que la transition vers un emploi garanti par l'État est active
    if (v[0] == 0 && v[4] == 1) {
        v[0] = 3; // Le ménage obtient un emploi garanti par l'État
        v[2] = -1; // Aucune firme associée car c'est un emploi garanti par l'État
        v[5] = V("MinimumWage"); // Salaire fixé par l'État pour l'emploi garanti
    }

    // Gestion des ménages en emploi
    if (v[0] == 1) { // Le ménage est en emploi brun non qualifié
        if (v[22] > 0) { // L'entreprise doit réduire des emplois bruns non qualifiés
            v[30] = V("BrownLowSkilledRetainProbability"); // Probabilité de conserver l'emploi brun non qualifié
            if (RND > v[30]) { // Le ménage est licencié
                v[0] = 0; // Statut chômage
                v[22] -= 1; // Réduction des licenciements bruns non qualifiés nécessaires
                v[2] = -1; // Ménage sans employeur après licenciement
            }
        }
    } else if (v[0] == 2) { // Le ménage est en emploi vert non qualifié
        if (v[24] > 0) { // L'entreprise doit réduire des emplois verts non qualifiés
            v[31] = V("GreenLowSkilledRetainProbability"); // Probabilité de conserver l'emploi vert non qualifié
            if (RND > v[31]) { // Le ménage est licencié
                v[0] = 0; // Statut chômage
                v[24] -= 1; // Réduction des licenciements verts non qualifiés nécessaires
                v[2] = -1; // Ménage sans employeur après licenciement
            }
        }
    } else if (v[0] == 4) { // Le ménage est en emploi brun qualifié
        if (v[23] > 0) { // L'entreprise doit réduire des emplois bruns qualifiés
            v[32] = V("BrownHighSkilledRetainProbability"); // Probabilité de conserver l'emploi brun qualifié
            if (RND > v[32]) { // Le ménage est licencié
                v[0] = 0; // Statut chômage
                v[23] -= 1; // Réduction des licenciements bruns qualifiés nécessaires
                v[2] = -1; // Ménage sans employeur après licenciement
            }
        }
    } else if (v[0] == 5) { // Le ménage est en emploi vert qualifié
        if (v[25] > 0) { // L'entreprise doit réduire des emplois verts qualifiés
            v[33] = V("GreenHighSkilledRetainProbability"); // Probabilité de conserver l'emploi vert qualifié
            if (RND > v[33]) { // Le ménage est licencié
                v[0] = 0; // Statut chômage
                v[25] -= 1; // Réduction des licenciements verts qualifiés nécessaires
                v[2] = -1; // Ménage sans employeur après licenciement
            }
        }
    }

    // Embauche dans les emplois bruns non qualifiés
    if (v[0] == 0 && v[22] > 0) { // Le ménage est au chômage et des postes bruns non qualifiés sont disponibles
        if (v[3] == 0) { // Si le ménage est de basse qualification
            v[0] = 1; // Le ménage est embauché en emploi brun non qualifié
            v[2] = v[2]; // Met à jour l'IdFirm avec l'IdFirm de la firme employant le ménage
            v[22] -= 1; // Réduction du nombre de postes bruns non qualifiés disponibles
            v[5] = v[10]; // Salaire de l'emploi brun non qualifié
        }
    }
    // Embauche dans les emplois bruns qualifiés
    if (v[0] == 0 && v[23] > 0 && v[3] == 1) { // Le ménage est au chômage, des postes bruns qualifiés sont disponibles et il a une haute qualification
        v[0] = 4; // Le ménage est embauché en emploi brun qualifié
        v[2] = v[2]; // Met à jour l'IdFirm avec l'IdFirm de la firme employant le ménage
        v[23] -= 1; // Réduction du nombre de postes bruns qualifiés disponibles
        v[5] = v[11]; // Salaire de l'emploi brun qualifié
    }
    // Embauche dans les emplois verts non qualifiés
    if (v[0] == 0 && v[24] > 0) { // Le ménage est au chômage et des postes verts non qualifiés sont disponibles
        if (v[3] == 0) { // Si le ménage est de basse qualification
            v[0] = 2; // Le ménage est embauché en emploi vert non qualifié
            v[2] = v[2]; // Met à jour l'IdFirm avec l'IdFirm de la firme employant le ménage
            v[24] -= 1; // Réduction du nombre de postes verts non qualifiés disponibles
            v[5] = v[12]; // Salaire de l'emploi vert non qualifié
        }
    }
    // Embauche dans les emplois verts qualifiés
    if (v[0] == 0 && v[25] > 0 && v[3] == 1) { // Le ménage est au chômage, des postes verts qualifiés sont disponibles et il a une haute qualification
        v[0] = 5; // Le ménage est embauché en emploi vert qualifié
        v[2] = v[2]; // Met à jour l'IdFirm avec l'IdFirm de la firme employant le ménage
        v[25] -= 1; // Réduction du nombre de postes verts qualifiés disponibles
        v[5] = v[13]; // Salaire de l'emploi vert qualifié
    }
}

RESULT(v[0]) // Retourne le statut d'emploi du ménage




EQUATION("WageBill")
/*
Wage bill of a given firm. Depends on profits and the bargaining power of workers (related to unemployment rate).
*/

v[0] = V("UnemploymentRate");  // Taux de chômage
v[1] = V("Profits");           // Profits de la firme
v[2] = V("Wageshare");         // Part des salaires

v[3] = v[1] * v[2] + (1 - v[0]);  // Masse salariale en fonction des profits, de la part des salaires et du taux de chômage

RESULT(v[3]);  // Retourne le résultat de la masse salariale




EQUATION("IndividualSalary")
/*
Cette équation détermine les salaires individuels des employés d'une entreprise,
de manière à ce que la somme des salaires individuels égale la masse salariale (WageBill)
définie précédemment pour chaque firme.
*/

CYCLE(cur, "Firms") {
    // Récupérer l'ID de la firme
    v[0] = VLS(cur, "IDFirm", 1);  // ID de la firme

    // Récupérer la masse salariale de la firme (WageBill)
    v[1] = V("Wagebill");  // Masse salariale de la firme

    // Récupérer le nombre d'employés dans la firme
    v[2] = V("NumEmployees");  // Nombre d'employés de la firme

    // Calcul du salaire de base par employé (partage équitable de la masse salariale entre les employés)
    v[3] = v[1] / v[2];  // Salaire de base égal à la masse salariale divisée par le nombre d'employés

    // Parcours des ménages pour associer les salaires à chaque employé de la firme
    CYCLE(cur, "Households") {
        // Vérifier que l'employé appartient à la firme actuelle
        v[4] = VLS(cur, "IdFirm", 1);  // ID de la firme de l'employé
        if (v[4] == v[0]) {  // Si l'employé appartient à cette firme
            // Mise à jour du salaire de l'employé
            RESULT(v[3]);  // Résultat pour l'employé : salaire de base de la firme
        }
    }
}


EQUATION("BaseWage")
/*
Détermine le salaire de base dans une firme en fonction du salaire minimum et d'un facteur de productivité.
*/
v[0] = V("MinimumWage");  // Salaire minimum fixé au niveau global
v[1] = V("ProductivityFactor");  // Facteur de productivité spécifique à la firme

v[2] = v[0] * v[1];

RESULT( v[2])  // Ajustement du salaire en fonction de la productivité




EQUATION("LowSkilledBrownWage")
/*
Salaire des travailleurs peu qualifiés dans une firme brune.
*/
v[0] = V("BaseWage");  // Salaire de base fixé par la firme

RESULT(v[0])  // Aucun premium pour les travailleurs peu qualifiés bruns



EQUATION("LowSkilledGreenWage")
/*
Salaire des travailleurs peu qualifiés dans une firme verte.
*/
v[0] = V("BaseWage");  
v[1] = V("GreenPremium");  // Prime pour les emplois verts

v[2] = v[0] * (1 + v[1]);

RESULT(v[2])  // Applique la prime verte





EQUATION("HighSkilledBrownWage")
/*
Salaire des travailleurs qualifiés dans une firme brune.
*/
v[0] = V("BaseWage");  
v[1] = V("SkillPremium");  // Prime pour les emplois qualifiés

v[2] = v[0] * (1 + v[1]);

RESULT( v[2])  // Applique la prime de qualification




EQUATION("HighSkilledGreenWage")
/*
Salaire des travailleurs qualifiés dans une firme verte.
*/
v[0] = V("BaseWage");  
v[1] = V("SkillPremium");  
v[2] = V("GreenPremium"); 

v[3] = v[0] * (1 + v[1] + v[2]);
 
RESULT( v[3])  // Applique les deux primes (qualification + vert)





/*EQUATIONS RELATIVES AUX BANQUES*/




EQUATION("DepositInterestRate")
/*
Taux d'intérêt sur les dépôts selon les hypothèses post-keynésiennes:
- Taux directeur de la banque centrale,
- Part de marché de la banque,
- Risque de crédit (exposition aux défauts),
- Taux de réserve obligatoire,
- Préférence pour la liquidité dans le secteur bancaire.
*/

v[0] = V("CentralBankRate");           // Taux directeur de la banque centrale (i_CB)
v[1] = V("MarketShareBank");           // Part de marché de la banque
v[2] = V("CreditConstraintVar");                // Risque de crédit (variable entre 0 et 1)
v[3] = V("ReserveRequirement");        // Taux de réserve obligatoire (variable entre 0 et 1)
v[4] = V("LiquidityPreference");       // Préférence pour la liquidité (variable entre 0 et 1)
v[5] = V("BaseMarkup");                // Mark-up de base (ajusté par le risque de crédit et la part de marché)

v[6] = v[0] + (v[1] * v[5]) - (v[2] * 0.1) - (v[3] * 0.2) + (v[4] * 0.15);  // Calcul du taux d'intérêt sur les dépôts

RESULT(v[6])




EQUATION("LoanInterestRate")
/*
Calculate the loan interest rate based on:
- Central bank interest rate,
- A mark-up depending on the bank's market share,
- A factor reflecting the credit constraint.
*/

v[0] = V("CentralBankRate");        // Central bank interest rate (i_BC)
v[1] = V("MarketShareBank");        // Bank's market share (as a fraction between 0 and 1)
v[2] = V("CreditConstraintInt");       // Credit constraint (value between 0 and 1)
v[3] = V("BaseMarkup");             // Base mark-up for market share impact (e.g., 0.02), représente l'effet maximum de la part de marché et de la contrainte sur le taux

v[4] = v[3] * v[1];                 // Mark-up proportional to market share
v[5] = v[0] + v[4] + v[2] * v[3];   // Final loan interest rate

RESULT(v[5])


EQUATION("GreenLoanInterestRate")
/*
Calcul du taux d'intérêt sur les prêts verts :
- Taux directeur de la banque centrale,
- Mark-up basé sur la part de marché de la banque,
- Facteur de contrainte de crédit,
- Facteur spécifique pour les prêts verts (réduction de taux d'intérêt).
*/

v[0] = V("CentralBankRate");           // Taux directeur de la banque centrale (i_CB)
v[1] = V("MarketShareBank");           // Part de marché de la banque
v[2] = V("CreditConstraintVar");          // Contrainte de crédit (valeur entre 0 et 1)
v[3] = V("BaseMarkup");                // Mark-up de base pour l'impact de la part de marché
v[4] = v[3] * v[1];                   // Mark-up proportionnel à la part de marché
v[5] = V("GreenLoanFactor");           // Facteur spécifique aux prêts verts (réduction du taux)
v[6] = v[0] + v[4] + v[2] * v[3] - v[5];  // Calcul du taux d'intérêt pour les prêts verts

RESULT(v[6])



EQUATION("MarketShareBank")
/*
Calculate the market share of a bank based on its total loans compared to the total loans in the system.
*/

v[0] = V("BankLoans");              // Total loans granted by the current bank
v[1] = SUM("BankLoans");            // Total loans granted by all banks

v[2] = (v[1] > 0) ? v[0] / v[1] : 0; // Market share as a fraction (0 if no loans in the system)

RESULT(v[2])


EQUATION("BankLoans")
/*
Total quantity of loans granted by the bank
*/

v[0] = V("LoanCons");
v[1] = V("GreenLoans");
v[2] = V("BrownLoans");

v[3] = v[0] + v[1] + v[2];

RESULT( v[3])


EQUATION("GreenLoansVar")
/*
Total quantity of loans granted by the bank
*/

    v[0] = V("GreenLoansDem");          // Demande de prêts verts
    v[1] = V("CreditConstraintVar");   // Variable de contrainte de crédit
    v[2] = v[0] * (1 - v[1]);          // Calcul des nouveaux prêts verts

RESULT(v[2])


EQUATION("BrownLoansVar")
/*
Total quantity of loans granted by the bank
*/

    v[0] = V("BrownLoansDem");          // Demande de prêts verts
    v[1] = V("CreditConstraintVar");   // Variable de contrainte de crédit
    v[2] = v[0] * (1 - v[1]);          // Calcul des nouveaux prêts verts

RESULT(v[2])


EQUATION("GreenLoans")
/*
Comment
*/

v[0] = VL("GreenLoans", 1);
v[1] = V("GreenLoansVar");

v[2] = v[0] + v[1];

RESULT( v[2])


EQUATION("BrownLoans")
/*
Comment
*/

v[0] = VL("BrownLoans", 1);
v[1] = V("BrownLoansVar");

v[2] = v[0] + v[1];

RESULT( v[2])


EQUATION("GreenLoansSec")
/*
Comment
*/

v[0] = SUM("GreenLoans");

RESULT( v[0])


EQUATION("BrownLoansSec")
/*
Comment
*/

v[0] = SUM("BrownLoans");

RESULT( v[0])




EQUATION("CreditConstraintVar")
/*
Calculation of credit constraint based on the difference between firm's leverage and target leverage.
The result is normalized to fall between 0 and 1.
*/

v[0] = V("LeverageFirm");         // Current leverage of the firm
v[1] = V("TargetLeverage");       // Target leverage set by banks
v[2] = V("MaxLeverageDifference"); // Maximum allowed difference between leverages (for normalization)

v[3] = v[0] - v[1];               // Difference between observed and target leverage
v[4] = (v[3] / v[2] < 0) ? 0 : (v[3] / v[2] > 1) ? 1 : v[3] / v[2];  // Normalize difference to the range [0, 1]

RESULT(v[4])



EQUATION("CreditConstraintInt")
/*
Calculation of credit constraint based on the difference between firm's leverage and target leverage.
The result is normalized to fall between 0 and 1.
*/

v[0] = V("LeverageFirm");         // Current leverage of the firm
v[1] = V("TargetLeverage");       // Target leverage set by banks
v[2] = V("MaxLeverageDifference"); // Maximum allowed difference between leverages (for normalization)

v[3] = v[0] - v[1];               // Difference between observed and target leverage
v[4] = (v[3] / v[2] < 0) ? 0 : (v[3] / v[2] > 1) ? 1 : v[3] / v[2];  // Normalize difference to the range [0, 1]

RESULT(v[4])



EQUATION("FirmBankSelection")
/*
Processus de sélection des banques par la firme basé sur le taux d'intérêt :
1. La firme garde la même banque si le taux d'intérêt est inférieur au taux moyen du marché.
2. Si la firme n'est pas satisfaite, elle choisit une nouvelle banque avec un taux d'intérêt inférieur au taux moyen du marché.
*/

v[0] = VLS(cur, "IdFirm", 1);                   // Identifiant de la firme (cur)
v[1] = VLS(cur, "PreviousBank", 1);             // Banque utilisée précédemment
v[2] = VLS(cur, "InterestRatePreviousBank", 1); // Taux d'intérêt de la banque précédente
v[3] = VLS(cur, "MarketInterestRate", 1);       // Taux d'intérêt moyen du marché
v[4] = -1;                                     // Variable pour stocker la banque choisie
v[5] = 0;                                      // Compteur pour itérer sur les banques disponibles

// Boucle pour itérer sur les banques disponibles
CYCLE(cur, "Banks") {
    v[6] = VLS(cur, "IdBank", 1);               // Identifier la banque
    v[7] = VLS(cur, "LoanInterestRate", 1);      // Taux d'intérêt de la banque en cours

    // Si le taux d'intérêt est inférieur au taux moyen du marché
    if (v[7] < v[3]) {
        // Si aucune banque n'a été encore choisie
        if (v[4] == -1) {
            v[4] = v[6];  // Choisir cette banque
        }
    }
    v[5] = v[5] + 1;                            // Incrémenter le compteur de banques
}

// Si aucune banque n'a été trouvée avec un taux inférieur au taux moyen
if (v[4] == -1) {
    v[4] = v[1];                               // Garder la banque initiale si aucune meilleure n'est trouvée
}

// Mise à jour de l'IdBank de la firme en utilisant WRITES
WRITES(cur, "IdBank", v[4]);  // Mettre à jour la banque choisie

RESULT(v[4])  // Retourner la banque choisie




EQUATION("HouseholdBankDecision")
/*
Processus de décision du ménage pour choisir une banque :
1. Le ménage évalue les banques disponibles et sélectionne celle qui offre un meilleur taux d'intérêt sur les dépôts
   ET un ratio d'actifs verts supérieur.
2. Si aucune banque ne répond à ces critères, le ménage conserve sa banque actuelle.
*/

v[0] = VS(cur, "IdBank");                // Banque actuelle du ménage
v[1] = VS(cur, "DepositInterestRate");   // Taux d'intérêt actuel sur les dépôts du ménage
v[2] = VS(cur, "GreenAssetRatio");       // Ratio d'actifs verts de la banque actuelle
v[3] = v[0];                             // Initialiser avec la banque actuelle

//    object *bank;                            // Déclarer un pointeur pour itérer sur les banques

// Parcourir les banques disponibles
CYCLE(cur, "Banks") {
    v[5] = VS(cur, "IdBank");                // Identifiant de la banque en cours
    v[6] = VS(cur, "DepositInterestRate");   // Taux d'intérêt de la banque en cours
    v[7] = VS(cur, "GreenAssetRatio");       // Ratio d'actifs verts de la banque en cours

    // Vérifier si la banque actuelle est meilleure
    if (v[6] > v[1] && v[7] > v[2]) {         // Conditions pour changer de banque
        v[3] = v[5];                          // Sélectionner cette banque
        v[1] = v[6];                          // Mettre à jour les critères de comparaison
        v[2] = v[7];                          // Mettre à jour les critères de comparaison
    }
}

// Mettre à jour la banque du ménage si elle a changé
WRITES(cur, "IdBank", v[3]);  // Mise à jour de la banque choisie pour le ménage

RESULT(v[3])  // Retourner l'identifiant de la banque choisie




EQUATION("GreenAssetRatio")
/*
Green Asset Ratio
*/


v[0] = V("GreenLoans");              // Total loans granted by the current bank
v[1] = V("BankLoans");            // Total loans granted by all banks

v[2] = v[0] / v[1];

RESULT(v[2])





EQUATION("BankProfit")
/*
Calcul du profit de la banque en fonction des intérêts perçus sur les prêts verts, les prêts bruns,
et des intérêts payés sur les dépôts.
*/

v[0] = V("GreenLoanInterestRate");   // Taux d'intérêt des prêts verts
v[1] = V("LoanInterestRate");   // Taux d'intérêt des prêts bruns
v[2] = V("GreenLoans"); // Montant total des prêts verts
v[3] = V("BrownLoans"); // Montant total des prêts bruns
v[4] = V("Dep");   // Montant total des dépôts
v[5] = V("DepositInterestRate");     // Taux d'intérêt payé sur les dépôts
v[6] = V("LoanRateCons");
v[7] = V("LoanCons");

// Calcul des intérêts perçus sur les prêts verts et bruns, moins les intérêts payés sur les dépôts
v[6] = (v[0] * v[2]) + (v[1] * v[3]) + (v[6] * v[7]) - (v[5] * v[4]); // Profit net de la banque

RESULT(v[6]);  // Retourner le profit net de la banque



EQUATION("ConsumerCreditRisk")
/*
Modélisation normalisée du risque financier d'un ménage emprunteur dans le cadre d'un crédit à la consommation.
1. Calcul de la mensualité basée sur le montant emprunté, le taux d'intérêt et la durée du crédit.
2. Calcul du taux d'endettement.
3. Calcul de l'indicateur de solvabilité.
4. Calcul de la probabilité de défaut en fonction du taux d'endettement.
5. Normalisation du risque financier total pour la banque pour le ramener à un intervalle [0, 1].
*/

v[0] = V("LoanCons");            // Montant du crédit à la consommation (C)
v[1] = V("InterestRate");          // Taux d'intérêt du crédit (r)
v[2] = V("CreditDuration");        // Durée du crédit en mois (T)
v[3] = V("Ydisp");                // Revenu du ménage (Y)
v[4] = V("TotalDebt");             // Dette totale du ménage (D)

// Calcul de la mensualité du crédit à la consommation
v[5] = v[0] * v[1] / (1 - pow(1 + v[1], -v[2]));  // Formule d'amortissement du crédit

// Calcul du taux d'endettement (E)
v[6] = v[4] / v[3];               // Taux d'endettement : D / Y

// Calcul de l'indicateur de solvabilité (I)
v[7] = v[3] - v[4];               // Solvabilité : Y - D

// Calcul de la probabilité de défaut (p_d) basée sur le taux d'endettement
v[8] = v[6] / (1 + v[6]);         // Probabilité de défaut : E / (1 + E)

// Normalisation du risque financier total
v[9] = v[8] * v[5];               // Risque financier total : p_d * M

// Normalisation pour obtenir un résultat compris entre 0 et 1
v[10] = v[9] / (V("MaxRiskValue"));  // Diviser par une valeur maximale théorique de risque

RESULT(v[10])                      // Retourner le risque financier normalisé



EQUATION("MaxRiskValue")
/*
Calcul du risque financier maximal pour un ménage emprunteur dans le cadre d'un crédit à la consommation.
La valeur de risque est fonction de la mensualité maximale et de la probabilité de défaut maximale.
*/

v[11] = V("MaxLoanAmount");            // Montant maximal du crédit à la consommation (C_max)
v[12] = V("MaxInterestRate");          // Taux d'intérêt maximal (r_max)
v[13] = V("MinCreditDuration");        // Durée minimale du crédit (T_min) (en mois)

v[14] = v[11] * v[12] / (1 - pow(1 + v[12], -v[13]));  // Calcul de la mensualité maximale (M_max)

// Maximum du taux d'endettement (E_max), supposé être 1 dans le pire scénario
v[15] = 1;  // Taux d'endettement maximal (E_max) = 1 (100%)

// Maximum de la probabilité de défaut (p_d_max), supposée être 1 pour un ménage avec un taux d'endettement maximal
v[16] = v[15] / (1 + v[15]);         // Probabilité de défaut maximale (p_d_max)

// Calcul du risque financier maximal (MaxRiskValue)
v[17] = v[16] * v[14];               // Risque financier maximal : p_d_max * M_max

RESULT(v[17])                         // Retourner la valeur maximale du risque



EQUATION("ConsumerLoanBankSelection")
/*
Le ménage choisit toujours la banque qu'il a choisie pour ses dépôts pour prendre son crédit à la consommation.
*/

v[0] = V("DepositBank");            // Banque choisie par le ménage pour ses dépôts
v[1] = V("PreviousLoanBank");      // Banque utilisée précédemment pour le crédit à la consommation
v[2] = -1;                         // Indicateur pour la banque à choisir

// Si la banque actuelle du ménage pour ses dépôts est différente de la banque utilisée pour les crédits
if (v[0] != v[1]) {
    v[2] = v[0];  // Le ménage prend un crédit auprès de la banque où il a son dépôt
} else {
    v[2] = v[1];  // Sinon, il reste avec la banque qu'il avait précédemment pour son crédit à la consommation
}

RESULT(v[2])                      // Retourner la banque choisie pour le crédit à la consommation





/*EQUATIONS RELATIVES A LA NATURE*/



// Déclaration des équations

EQUATION("Ener")
    v[0] = V("epsilon");    // epsilon
    v[1] = V("Y");          // Y
    
    v[2] = v[0] * v[1];     // Calcul de Ener
    RESULT(v[2])


EQUATION("ER")
    v[0] = V("rensh");      // rensh
    v[1] = V("Ener");       // Ener
    
    v[2] = v[0] * v[1];     // Calcul de ER
    RESULT(v[2])

EQUATION("rensh")
    v[0] = V("K_V(-1)");    // K_V(-1)
    v[1] = V("K_B(-1)");    // K_B(-1)
    
    v[2] = 1 + (1 / (M_PI * (v[0] / v[1])));  // Calcul de rensh
    v[3] = pow(v[2], -1);  // Inverse de la valeur
    
    RESULT(v[3])

EQUATION("EN")
    v[0] = V("Ener");       // Ener
    v[1] = V("ER");         // ER
    
    v[2] = v[0] - v[1];     // Calcul de EN
    RESULT(v[2])

EQUATION("EMIS_EN")
    v[0] = V("emisen");     // emisen
    v[1] = V("emish");      // emish
    v[2] = V("EN");         // EN
    
    v[3] = (v[0] > 0) * (v[1] * v[2]) + (v[0] < 0) * 0;  // Calcul de EMIS_EN
    RESULT(v[3])

EQUATION("emisen")
    v[0] = V("emish");      // emish
    v[1] = V("EN");         // EN
    
    v[2] = v[0] * v[1];     // Calcul de emisen
    RESULT(v[2])

EQUATION("REV_E")
    v[0] = V("REV_E_var");  // REV_E_var
    
    RESULT(v[0])

EQUATION("REV_E_var")
    v[0] = V("REV_E(-1)");  // REV_E(-1)
    v[1] = V("CON_E");      // CON_E
    v[2] = V("EN");         // EN
    
    v[3] = (v[0] > 2000) * (v[0] + v[1] - v[2]) + (v[0] < 2000) * 1;  // Calcul de REV_E_var
    RESULT(v[3])

EQUATION("CON_E")
    v[0] = V("cons_E");     // cons_E
    v[1] = V("RES_E(-1)");  // RES_E(-1)
    
    v[2] = v[0] * v[1];     // Calcul de CON_E
    RESULT(v[2])

EQUATION("RES_E")
    v[0] = V("RES_E(-1)");  // RES_E(-1)
    v[1] = V("CON_E");      // CON_E
    
    v[2] = v[0] - v[1];     // Calcul de RES_E
    RESULT(v[2])

EQUATION("dep_E")
    v[0] = V("EN");         // EN
    v[1] = V("REV_E(-1)");  // REV_E(-1)
    
    v[2] = v[0] / v[1];     // Calcul de dep_E
    RESULT(v[2])

EQUATION("EMIS_L")
    v[0] = V("EMIS_L(-1)"); // EMIS_L(-1)
    v[1] = V("landusech");  // landusech
    
    v[2] = v[0] * (1 - v[1]);  // Calcul de EMIS_L
    RESULT(v[2])

EQUATION("EMIS")
    v[0] = V("EMIS_EN");    // EMIS_EN
    v[1] = V("EMIS_L");     // EMIS_L
    
    v[2] = v[0] + v[1];     // Calcul de EMIS
    RESULT(v[2])

EQUATION("CO2_AT")
    v[0] = V("EMIS");       // EMIS
    v[1] = V("phi_11");     // phi_11
    v[2] = V("CO2_AT(-1)"); // CO2_AT(-1)
    v[3] = V("phi_21");     // phi_21
    v[4] = V("CO2_UP(-1)"); // CO2_UP(-1)
    
    v[5] = v[0] + v[1] * v[2] + v[3] * v[4];  // Calcul de CO2_AT
    RESULT(v[5])

EQUATION("CO2_UP")
    v[0] = V("phi_12");     // phi_12
    v[1] = V("CO2_AT(-1)"); // CO2_AT(-1)
    v[2] = V("phi_22");     // phi_22
    v[3] = V("CO2_UP(-1)"); // CO2_UP(-1)
    v[4] = V("phi_32");     // phi_32
    v[5] = V("CO2_LO(-1)"); // CO2_LO(-1)
    
    v[6] = v[0] * v[1] + v[2] * v[3] + v[4] * v[5];  // Calcul de CO2_UP
    RESULT(v[6])

EQUATION("CO2_LO")
    v[0] = V("phi_23");     // phi_23
    v[1] = V("CO2_UP(-1)"); // CO2_UP(-1)
    v[2] = V("phi_33");     // phi_33
    v[3] = V("CO2_LO(-1)"); // CO2_LO(-1)
    
    v[4] = v[0] * v[1] + v[2] * v[3];  // Calcul de CO2_LO
    RESULT(v[4])

EQUATION("varlog")
    v[0] = V("RF_2CO2");    // RF_2CO2
    v[1] = V("CO2_AT");     // CO2_AT
    v[2] = V("CO2_ATPRE");  // CO2_ATPRE
    
    v[3] = v[0] * (v[1] / v[2]);  // Calcul de varlog
    RESULT(v[3])

EQUATION("RF")
    v[0] = V("RF_2CO2");    // RF_2CO2
    v[1] = V("CO2_AT");     // CO2_AT
    v[2] = V("CO2_ATPRE");  // CO2_ATPRE
    
    v[3] = log(v[0] * (v[1] / v[2])) / log(4);  // Calcul de RF
    RESULT(v[3])

EQUATION("F_EX")
    v[0] = V("F_EX(-1)");   // F_EX(-1)
    v[1] = V("fex");        // fex
    
    v[2] = v[0] + v[1];     // Calcul de F_EX
    RESULT(v[2])

EQUATION("T_AT")
    v[0] = V("T_AT(-1)");   // T_AT(-1)
    v[1] = V("RF");         // RF
    v[2] = V("RF_2CO2");    // RF_2CO2
    v[3] = V("CS");         // CS
    v[4] = V("t_1");        // t_1
    v[5] = V("t_2") ;       // t_2
    v[6] = V("T_LO(-1)");   // T_LO(-1)
    
    v[7] = v[1] - (v[2] / v[3]);   // Calcul de (RF - (RF_2CO2 / CS))
    v[8] = v[7] * v[0] - v[5] * (v[0] - v[6]);  // Calcul de T_AT
    v[9] = v[4] * v[8];             // Finalisation de T_AT
    RESULT(v[9])

EQUATION("T_LO")
    v[0] = V("T_LO(-1)");   // T_LO(-1)
    v[1] = V("T_AT(-1)");   // T_AT(-1)
    v[2] = V("t_3");        // t_3
    
    v[3] = v[1] - v[0];     // Calcul de (T_AT(-1) - T_LO(-1))
    v[4] = v[2] * v[3];     // Calcul de T_LO
    v[5] = v[0] + v[4];     // Finalisation de T_LO
    RESULT(v[5])


EQUATION("D_T")
    v[0] = V("eta_1") * V("T_AT") + V("eta_2") * pow(V("T_AT"), 2) + V("eta_3") * pow(V("T_AT"), 6.754);
    v[1] = 1 + v[0];
    v[2] = 1 / v[1];
    RESULT(1 - v[2]);

EQUATION("D_TP")
    v[0] = V("dampar") * V("D_T");
    RESULT(v[0]);

EQUATION("D_TF")
    v[0] = 1 - V("D_T");
    v[1] = 1 - V("D_TP");
    v[2] = v[0] / v[1];
    RESULT(1 - v[2]);

EQUATION("delta")
    v[0] = V("delta_0");
    v[1] = 1 - v[0];
    v[2] = 1 - V("adK");
    v[3] = V("D_TF(-1)");
    v[4] = v[1] * v[2] * v[3];
    RESULT(v[0] + v[4]);

EQUATION("vdam")
    v[0] = V("vdam(-1)") * (1 + V("gv"));
    v[1] = 1 - (1 - V("adP")) * V("D_TP(-1)");
    RESULT(v[0] * v[1]);

// Effet rebond

EQUATION("MY")
    v[0] = V("mu") * V("Y");
    RESULT(v[0]);

EQUATION("M")
    v[0] = V("MY") - V("REC");
    RESULT(v[0]);

EQUATION("REC")
    v[0] = V("rho") * V("DEM");
    RESULT(v[0]);

EQUATION("DEM")
    v[0] = V("mu") * (V("delta") * V("K(-1)") + V("zig") * V("DC(-1)"));
    RESULT(v[0]);

EQUATION("DC")
    v[0] = V("DC(-1)") + V("C_R") + V("C_U") - V("zig") * V("DC(-1)");
    RESULT(v[0]);

EQUATION("Waste")
    v[0] = V("M") + V("CEN") + V("O2") - V("EMIS_EN") - (V("SES") - V("SES(-1)"));
    RESULT(v[0]);

EQUATION("SES")
    v[0] = V("SES(-1)") + V("MY") - V("DEM");
    RESULT(v[0]);

EQUATION("CEN")
    v[0] = V("EMIS_EN") / V("car");
    RESULT(v[0]);

EQUATION("O2")
    v[0] = V("EMIS_EN") - V("CEN");
    RESULT(v[0]);

EQUATION("HWS")
    v[0] = V("HWS(-1)") + V("haz") * V("W");
    RESULT(v[0]);

EQUATION("hazratio")
    v[0] = V("HWS") / V("SURF");
    RESULT(v[0]);

EQUATION("REV_M")
    v[0] = V("REV_M_var");
    RESULT(v[0]);

EQUATION("REV_M_var")
    v[0] = (V("REV_M(-1)") > 300) * (V("REV_M(-1)") + V("CON_M") - V("M")) + (V("REV_M(-1)") < 300) * 1;
    RESULT(v[0]);

EQUATION("CON_M")
    v[0] = V("cons_M") * V("RES_M(-1)");
    RESULT(v[0]);

EQUATION("RES_M")
    v[0] = V("RES_M(-1)") - V("CON_M");
    RESULT(v[0]);

EQUATION("dep_M")
    v[0] = V("M") / V("REV_M(-1)");
    RESULT(v[0]);

EQUATION("mu")
    v[0] = V("greencapratio(-1)") * V("mu_V") + (1 - V("greencapratio(-1)")) * V("mu_B");
    RESULT(v[0]);

EQUATION("mu_V")
    v[0] = V("mu_V(-1)") * (1 - V("mu_0V"));
    RESULT(v[0]);

EQUATION("rho")
    v[0] = V("greencapratio(-1)") * V("rho_V") + (1 - V("greencapratio(-1)")) * V("rho_B");
    RESULT(v[0]);

EQUATION("rho_V")
    v[0] = V("rho_V(-1)") * (1 - V("rho_0V"));
    RESULT(v[0]);





/*EQUATIONS RELATIVES A LA BANQUE CENTRALE*/














/*EQUATIONS RELATIVES AUX FIRMES*/






/*EQUATIONS RELATIVES A L'ACCUMULATION DU CAPITAL*/




EQUATION("Total Capital")
/*
Evolution of Total Capital
*/

v[0] = V("Brown Capital");
v[1] = V("Green Capital");

v[2] = v[0] + v[1];

RESULT( v[2])



EQUATION("Brown Capital")
/*
Evolution of brown capital.
*/

v[0] = VL("Brown Capital", 1);
v[1] = V("Brown Investment");
v[2] = V("Delta");

v[3] = v[0] + v[1] - (v[2] * v[0]);

RESULT( v[3])


EQUATION("Green Capital")
/*
Evolution of green capital.
*/

v[0] = VL("Green Capital", 1);
v[1] = V("Brown Investment");
v[2] = V("Delta");

v[3] = v[0] + v[1] - (v[2] * v[0]);

RESULT( v[3])


EQUATION("Brown Investment")
/*
Comment
*/

v[0] = V("BrownLoansVar");

RESULT( v[0])


EQUATION("Green Investment")
/*
Comment
*/

v[0] = V("GreenLoansVar");

RESULT( v[0])



EQUATION("BrownLoansDem")
/*
Comment
*/

v[0] = V("BrownInvDes");

RESULT( v[0])


EQUATION("GreenLoansDem")
/*
Comment
*/

v[0] = V("GreenInvDes");

RESULT( v[0])


EQUATION("BrownInvDes")
/*
Comment
*/

v[0] = V("GrKdB");
v[1] = VL("Brown Capital", 1);

v[2] = v[0] * v[1];

RESULT( v[2])


EQUATION("GreenInvDes")
/*
Comment
*/

v[0] = V("GrKdV");
v[1] = VL("Green Capital", 1);

v[2] = v[0] * v[1];

RESULT( v[2])


EQUATION("GrKdB")
/*
Comment
*/

v[0] = V("Animal Spirits_B");
v[1] = V("gamma1_B");
v[2] = V("gamma2_B");
v[3] = V("gamma3_B");
v[4] = V("gamma4_B");
v[5] = V("ratiocashflow");
v[6] = V("LeverageFirm");
v[7] = V("capacityutilization");
v[8] = V("BrownLoanInterestRate");

v[9] = v[0] + v[1] * v[5] - v[2] * v[6] + v[3] * v[7] - v[4] * v[8];

RESULT( v[9])


EQUATION("GrKdV")
/*
Comment
*/

v[0] = V("Animal Spirits_V");
v[1] = V("gamma1_V");
v[2] = V("gamma2_V");
v[3] = V("gamma3_V");
v[4] = V("gamma4_V");
v[5] = V("ratiocashflow");
v[6] = V("LeverageFirm");
v[7] = V("capacityutilization");
v[8] = V("GreenLoanInterestRate");

v[9] = v[0] + v[1] * v[5] - v[2] * v[6] + v[3] * v[7] - v[4] * v[8];

RESULT( v[9])



/*EQUATIONS RELATIVES AUX VENTES*/



EQUATION("Turnover")
/*
CA
*/
V("EndTrade");
v[0]=0;

CYCLE(cur, "Product")
 {
		v[1]=VLS(cur,"Price",1);
		v[2]=VS(cur,"Sales_Prod");
		v[0]=v[0]+v[1]*v[2];
  }
  
RESULT( v[0])



EQUATION("Share_Turn_P2")
/*
part du produit 2 ds le CA
*/
V("EndTrade");
v[0]=V("Turnover");

cur=SEARCH_CND("IdProduct",2);//cherche le produit 2 de la firme
v[1]=VLS(cur,"Price",1);
v[2]=VS(cur,"Sales_Prod");

if(v[0]==0)
v[3]=0;
else
v[3]=(v[1]*v[2])/v[0];

RESULT( v[3])



EQUATION("Adoption_Index_MS")
/*
indice pour decision d'adoption du produit 2 calcule sur MST2
*/
V("Budget");//on s'assure que les entrees et sorties ont eu lieu

v[0]=V("ms_Product2");
v[2]=V("Alpha_Regu");
v[3]=V("Sunset_Date");
v[6]=V("Revision_Period");


v[5]=v[0]*(1+v[2]*t/(v[3]+v[6]));


RESULT(v[5] )



EQUATION("Adoption_Product2")
/*
determine si la firme adopte le produit 2 => portefeuille de technlogies/produits
Porfolio: 1 si oui 0 si non
*/

V("EndTrade");
v[10]=V("Portfolio");

if(v[10]==0)//si le produit 2 n'est pas adopte
{

	v[0]=V("Adoption_Index_MS");
	v[1]=V("Adoption_Threshold_MS");// seuil pour adoption sur MS
	v[30]=V("K");//!!!!!!
	v[31]=V("Adoption_Threshold_K");// seuil pour adoption sur K !!!!!

	if(v[0]>v[1]&&v[30]>v[31])//si les deux indices depassent les seuils => adoption !!!!!
	{
		v[11]=V("Budget");
		v[12]=V("Switching_Costs");
		v[13]=v[11]-v[12];

		if(v[13]>=0)//adopte si le budget est suffisant
		{
		WRITE("Portfolio",1);
		WRITE("Switching_Period",t+1);//inscrit la periode +1 car paiement des switching costs sur le budget suivant
		CYCLE(cur, "Product")
 			{
  				v[2]=VS(cur,"IdProduct");
  				if(v[2]==2)
  				{
  					WRITES(cur,"IsAdopted",1);
  		
  					v[20]=V("K");// procedure changee !!!!!!!!!!!!!!!!
  					v[3]=V("Product2_Init_X");
  					v[4]=V("Product2_Init_Eff");
  					v[5]=V("Product2_Init_Tox");
  					v[6]=V("Product2_Init_Bio");
  					v[22]=VL("Absolute_maxX_P2",1);
  					v[23]=VL("Absolute_maxEff_P2",1);
  					v[24]=VL("Absolute_minTox_P2",1);
  					v[25]=VL("Absolute_minBio_P2",1);
  
  					WRITES(cur,"X",v[3]+v[20]*(v[22]-v[3]));
    					WRITES(cur,"Eff",v[4]+v[20]*(v[23]-v[4]));
      					WRITES(cur,"Tox",v[5]-v[20]*(v[5]-v[24]));
  					WRITES(cur,"Bio",v[6]-v[20]*(v[6]-v[25]));
  
  					}
 				}
		}
	}
}

RESULT( 1)


EQUATION("First_adoption")
/*
retourne la periode a laquelle la techno 2 a ete adoptee pour la premiere fois
*/
V("EndTrade");
v[1]=0;

CYCLE(cur, "Firm")
 {
  v[0]=VS(cur,"Portfolio");
  if(v[0]!=0)
  {
  	v[1]=t;
  	PARAMETER;
  }
 }

RESULT( v[1])




EQUATION("Only_Product2")
/*
determine si la firme abandonne le produit 1
OnlyProduct2 : 1 si oui, 0 sinon
*/
V("EndTrade");
V("Adoption_Product2");
v[3]=V("Portfolio");

v[10]=V("NewFirm");
if(v[10]==1)//si la firme est un nouvel entrant on quitte l'equation car le ROI n'est pas a jour
END_EQUATION(1);

if(v[3]==1)// si les deux produits sont adoptes
{
	v[0]=V("Share_Turn_P2");
	v[1]=V("Threshold_Abandon");

	v[4]=V("Regulation");
	if(v[4]==0)
	{
		if(v[0]>v[1])//si la part du produit 2 dans le chiffre d'affaire est sup au seuil => on abandonne produit 1
		{
			WRITE("OnlyProduct2",1);
			WRITE("Portfolio",2);//on inscrit 2 dans portfolio
			cur=SEARCH_CND("IdProduct",1);//cherche le produit 1 de la firme
			WRITES(cur,"IsAdopted",0);
		}
	}
 	else//si le produit 1 est interdit
 	{
 		WRITE("OnlyProduct2",1);
		WRITE("Portfolio",2);//on inscrit 2 dans portfolio
		cur=SEARCH_CND("IdProduct",1);//cherche le produit 1 de la firme
		WRITES(cur,"IsAdopted",0);
 	}	
 
}
RESULT( 1)



EQUATION("Price")
/*
Comment
*/

V("Innovation");// on s'assure que la firme a innove
v[0]=V("Markup");
v[1]=V("Costs");
v[2]=(1+v[0])*v[1];
RESULT( v[2])



EQUATION("Profits")
/*
Profits de la firme
*/
V("EndTrade");
v[3]=0;

CYCLE(cur, "Product")
 {
  v[0]=VLS(cur,"Markup",1);
  v[1]=VLS(cur,"Costs",1);
  v[2]=VS(cur,"Sales_Prod");
  v[3]=v[3]+v[0]*v[1]*v[2];
 }

v[4]=V("Fixed_Costs");
v[5]=v[3]-v[4];

RESULT( v[5])


EQUATION("Costs")
/*
Cout de production du produit
*/
V("Innovation");// on s'assure que la firme a innove
v[0]=V("A_Costs");
v[1]=V("B_Costs");
v[2]=V("C_Costs");
v[3]=V("D_Costs");
v[4]=V("X");
v[5]=V("Tox");
v[6]=V("Bio");
v[7]=V("Eff");
v[8]=V("Scale_Costs");

v[9]=v[8]*(v[4]-v[0])*(v[1]-v[5])*(v[2]-v[6])*(v[3]-v[7]);

RESULT(v[9] )



EQUATION("Budget")
/*
Budget de la firme
*/

V("TotalSales");// on s'assure que TotalSales a ete calcule car on risque ici de remettre des ventes a zero
V("Inverse_HHI");
V("Enter");//on s'assure que les entrees ont eu lieu

v[30]=V("NewFirm");
if(v[30]==1)//si la firme est un nouvel entrant
{
	v[31]=VL("Average_Budget",1);//son budget initial est le budget moyen
	v[5]=v[31];
}
else
{
v[0]=VL("Budget",1);
v[1]=V("Profits");
v[2]=VL("RD_Budget",1);

v[10]=V("Switching_Period");
if(t==v[10])
v[11]=V("Switching_Costs");
else
v[11]=0;

v[3]=v[0]+v[1]-v[2]-v[11];


if(v[3]<=0)
{
	WRITE("Dead",1);
	WRITE("Failure_Budget",1);//faillite liees a budget negatif
}
else
{
	WRITE("Dead",0);
	v[5]=v[3];
}


v[14]=V("Regulation");

if(v[14]==1)//si le produit 1 est interdit
{
	v[21]=V("Portfolio");

	if(v[21]==0)//si la firme ne developpe pas le produit 2 elle degage
	{
		WRITE("Dead",1);
		WRITE("Failure_T1",1);//faillite liees a la non adoption de la techno 2
	}
}


v[12]=V("Sunset_Date");
v[13]=V("Revision_Period");
v[20]=V("Revision_Period_Update");


if(t==(v[12]+v[13]-v[20])&&v[14]==0)//verifie la veille techno
{
	v[15]=VL("Average_RD_Watch",1);
	v[16]=V("Alpha_Regu_Watch");
	v[17]=VL("RD_Watch",1);
	v[18]=V("Portfolio");
	
	if(v[18]==0)//si le produit 2 pas adopte
	{
		if(v[17]<v[15]*v[16])//si veille insuffisante => a la porte
		{
			WRITE("Dead",1);
			WRITE("Failure_Watch",1);//faillites liees a veille insuffisante
		}
	}	

}
}

RESULT(v[5] )


EQUATION("Average_Budget")
/*
Le budget moyen  
*/

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")

 { 
   v[2]=VS(cur,"Budget");
   v[0]=v[0]+v[2];
   v[1]=v[1]+1;
   
  
 }

v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Failures")
/*
nombre cumule de faillites
*/
v[0]=VL("Failures",1);

CYCLE(cur, "Firm")//on s'assure que les budgets ont ete calcules et on calcule le nb cumule de faillites
 {
  VS(cur,"Budget");
  v[1]=VS(cur,"Dead");
  if(v[1]==1)
  {
  		v[0]=v[0]+1;
    v[2]=VS(cur,"Failure_Budget");
  		INCR("Total_Failures_Budget",v[2]);//nb total de faillites pour budget insuffisant
  		v[3]=VS(cur,"Failure_T1");
  		INCR("Total_Failures_T1",v[3]);//nb total de faillites pour non adoption T2
  		v[4]=VS(cur,"Failure_Watch");
  		INCR("Total_Failures_Watch",v[4]);//nb total de faillites pour veille insuffisante
  }
 }

RESULT(v[0] )



EQUATION("Exit")
/*
processus de sorties de firmes
*/
V("Failures");

CYCLE(cur, "Firm")//on fait sortir les firmes qui quittent le marche
 {
  VS(cur,"Budget");
  v[1]=VS(cur,"Dead");
  if(v[1]==1)
  {
  DELETE(cur);
  }
 }

RESULT(1 )



EQUATION("Enter")
/*
processus d'entree de firmes. En tt debut de periode, avant les echanges
*/
if(t==1)
END_EQUATION(0);

v[100]=VL("ms_Product1",1);
v[101]=VL("Average_X_T1",1);
v[102]=VL("Average_Tox_T1",1);
v[103]=VL("Average_Bio_T1",1);
v[104]=VL("Average_Eff_T1",1);
v[105]=V("Xmax_Prod1");
v[106]=V("Toxmin_Prod1");
v[107]=V("Biomin_Prod1");
v[108]=V("Effmax_Prod1");
v[109]=V("Product1_Init_X");
v[110]=V("Product1_Init_Tox");
v[111]=V("Product1_Init_Bio");
v[112]=V("Product1_Init_Eff");

v[120]=VL("ms_Product2",1);
v[121]=VL("Average_X_T2",1);
v[122]=VL("Average_Tox_T2",1);
v[123]=VL("Average_Bio_T2",1);
v[124]=VL("Average_Eff_T2",1);
v[125]=V("Xmax_Prod2");
v[126]=V("Toxmin_Prod2");
v[127]=V("Biomin_Prod2");
v[128]=V("Effmax_Prod2");
v[129]=V("Product2_Init_X");
v[130]=V("Product2_Init_Tox");
v[131]=V("Product2_Init_Bio");
v[132]=V("Product2_Init_Eff");

v[140]=V("Scale_Enter");//parametre d'echelle : proba max d'entrer

v[75]=v[140]*(v[100]*((v[105]-v[101])/(v[105]-v[109])+(v[102]-v[106])/(v[110]-v[106])+(v[103]-v[107])/(v[111]-v[107])+(v[108]-v[104])/(v[108]-v[112]))/4+v[120]*((v[125]-v[121])/(v[125]-v[129])+(v[122]-v[126])/(v[130]-v[126])+(v[123]-v[127])/(v[131]-v[127])+(v[128]-v[124])/(v[128]-v[132]))/4);// proba d'entrer basee sur le potentiel techno

v[76]=UNIFORM(0,1);

if(v[75]>v[76])//la firme entre si proba assez elevee
{ 

INCR("Nb_Enter",1);//nb total d'entrees

v[92]=MAX("IdFirm");
cur3=SEARCH_CND("IdFirm", v[92]);

cur=ADDOBJ_EX("Firm",cur3);


WRITES(cur,"IdFirm",v[92]+1);


WRITES(cur,"Dead",0);
WRITES(cur,"NewFirm",1);
WRITES(cur,"Entrant",1);
WRITES(cur,"Sales",0);
WRITES(cur,"Switching_Period",0);


v[25]=UNIFORM(0,1);// initialisation du seuil pour adoption produit2 sur MS !!!!!!
WRITES(cur,"Adoption_Threshold_MS",v[25]);

v[225]=UNIFORM(0,1);// initialisation du seuil pour adoption produit2 sur K !!!!!!
WRITES(cur,"Adoption_Threshold_K",v[225]);

v[0]=UNIFORM(0,1);// initialisation de la repartition de la RD
WRITES(cur,"RD_Split_Index",v[0]);

v[1]=UNIFORM(250,250);// initialisation des couts fixes A CHANGER: identique pour tout le monde
WRITES(cur,"Fixed_Costs",v[1]);

v[85]=UNIFORM(0.5,1);// initialisation du seuil pour abandonner produit 1
WRITES(cur,"Threshold_Abandon",v[85]);


v[150]=V("Benchmark");//controle si la configuration est le benchmark ou pas
if(v[150]==1)
v[151]=0;
else
v[151]=UNIFORM(0,1);

WRITES(cur,"Alpha_Regu",v[151]);


v[50]=VL("Average_Sw_Costs",1);
v[51]=V("Sw_Costsmin");
v[22]=UNIFORM(0.8,1.2);// initialisation des switching costs fct de la moyenne
v[52]=v[22]*v[50];
if (v[52]>v[51])
WRITES(cur,"Switching_Costs",v[52]);
else
WRITES(cur,"Switching_Costs",v[51]);


v[53]=VL("Average_K",1);
v[54]=V("Kmax");
v[24]=UNIFORM(0.8,1.2);// initialisation du stock de connaissances fct de la moyenne
v[55]=v[24]*v[53];
if(v[55]<v[54])
WRITES(cur,"K",v[55]);
else
WRITES(cur,"K",v[54]);


v[70]=VL("Regulation",1);

if(v[70]==0)
cur1=RNDDRAWL("Firm","ms_sales",1);// l'entrant choisi une firme a copier en fonction des pdm
else// si T1 est interdite
{
	CYCLE(cur2, "Firm")
 {
  v[71]=VS(cur2,"Portfolio");
  if(v[71]==0)
  	WRITES(cur2,"Probchosen",0);
  else
  {
  	v[72]=VLS(cur2,"ms_sales",1);
  	WRITES(cur2,"Probchosen",0.0001+v[72]);// on ajoute 0.0001 pour eviter le pb de la pdm = 0 pour tous
  }
 }

cur1=RNDDRAW("Firm","Probchosen");// l'entrant choisi une firme a copier en fonction des pdm

}


v[2]=VS(cur1,"IdFirm");//identifiant de la firme copiee
v[3]=VS(cur1,"Portfolio");
WRITES(cur,"Portfolio",v[3]);
v[4]=VS(cur1,"OnlyProduct2");
WRITES(cur,"OnlyProduct2",v[4]);


v[30]=UNIFORM(0.8,1.2);// capacite d'absorption de la nouvelle firme !!! 0.8;1.2
v[31]=(1-v[30])+1;//pour Tox et Bio

v[40]=V("Xmax_Prod1");
v[41]=V("Toxmin_Prod1");
v[42]=V("Effmax_Prod1");
v[43]=V("Biomin_Prod1");
v[44]=V("Xmax_Prod2");
v[45]=V("Toxmin_Prod2");
v[46]=V("Effmax_Prod2");
v[47]=V("Biomin_Prod2");
v[60]=V("Product1_Init_X");
v[61]=V("Product1_Init_Tox");
v[62]=V("Product1_Init_Eff");
v[63]=V("Product1_Init_Bio");

v[80]=V("Product2_Init_X");
v[81]=V("Product2_Init_Tox");
v[82]=V("Product2_Init_Eff");
v[83]=V("Product2_Init_Bio");


CYCLES(cur1, cur2, "Product")//copie les caracteristiques du produit 1
 {
  v[5]=VS(cur2,"IdProduct");
  if(v[5]==1)
  {
  v[6]=VS(cur2,"X");
  v[7]=VS(cur2,"Eff");
  v[8]=VS(cur2,"Tox");
  v[9]=VS(cur2,"Bio");
  v[10]=VS(cur2,"IsAdopted");
  }
 }

CYCLES(cur, cur2, "Product")//colle les caracteristiques du produit 1
 {
 v[11]=VS(cur2,"IdProduct");
  if(v[11]==1)
  {
  if(v[6]*v[30]>=v[40])
  WRITES(cur2,"X",v[40]);
  if(v[6]*v[30]<=v[60])
  WRITES(cur2,"X",v[60]);
  if(v[6]*v[30]>v[60]&&v[6]*v[30]<v[40])
  WRITES(cur2,"X",v[6]*v[30]);

  if(v[7]*v[30]>=v[42])
  WRITES(cur2,"Eff",v[42]);
  if(v[7]*v[30]<=v[62])
  WRITES(cur2,"Eff",v[62]);
  if(v[7]*v[30]>v[62]&&v[7]*v[30]<v[42])
  WRITES(cur2,"Eff",v[7]*v[30]);
  
  if(v[8]*v[31]<=v[41])
  WRITES(cur2,"Tox",v[41]);
  if(v[8]*v[31]>=v[61])
  WRITES(cur2,"Tox",v[61]);
  if(v[8]*v[31]>v[41]&&v[8]*v[31]<v[61])
  WRITES(cur2,"Tox",v[8]*v[31]);
  
  if(v[9]*v[31]<=v[43])
  WRITES(cur2,"Bio",v[43]);
  if(v[9]*v[31]>=v[63])
  WRITES(cur2,"Bio",v[63]);
  if(v[9]*v[31]>v[43]&&v[9]*v[31]<v[63])
  WRITES(cur2,"Bio",v[9]*v[31]);

  
  WRITES(cur2,"IsAdopted",v[10]);
  WRITES(cur2,"Sales_Prod",0);
  }
 }


CYCLES(cur1, cur2, "Product")//copie les caracteristiques du produit 2
 {
  v[15]=VS(cur2,"IdProduct");
  if(v[15]==2)
  {
  v[16]=VS(cur2,"X");
  v[17]=VS(cur2,"Eff");
  v[18]=VS(cur2,"Tox");
  v[19]=VS(cur2,"Bio");
  v[20]=VS(cur2,"IsAdopted");
  }
 }

CYCLES(cur, cur2, "Product")//colle les caracteristiques du produit 2
 {
 v[21]=VS(cur2,"IdProduct");
  if(v[21]==2)
  {
  	if(v[20]==1)// si le produit est adopte
  	{
  	if(v[16]*v[30]>=v[44])
  	WRITES(cur2,"X",v[44]);
  	if(v[16]*v[30]<=v[80])
  	WRITES(cur2,"X",v[80]);
  	if(v[16]*v[30]>v[80]&&v[16]*v[30]<v[44])
  	WRITES(cur2,"X",v[16]*v[30]);

  	if(v[17]*v[30]>=v[46])
  	WRITES(cur2,"Eff",v[46]);
  	if(v[17]*v[30]<=v[82])
  	WRITES(cur2,"Eff",v[82]);
  	if(v[17]*v[30]>v[82]&&v[17]*v[30]<v[46])
  	WRITES(cur2,"Eff",v[17]*v[30]);
  
  	if(v[18]*v[31]<=v[45])
  	WRITES(cur2,"Tox",v[45]);
  	if(v[18]*v[31]>=v[81])
  	WRITES(cur2,"Tox",v[81]);
  	if(v[18]*v[31]>v[45]&&v[18]*v[31]<v[81])
  	WRITES(cur2,"Tox",v[18]*v[31]);
  
  	if(v[19]*v[31]<=v[47])
  	WRITES(cur2,"Bio",v[47]);
  	if(v[19]*v[31]>=v[83])
  	WRITES(cur2,"Bio",v[83]);
  	if(v[19]*v[31]>v[47]&&v[19]*v[31]<v[83])
  	WRITES(cur2,"Bio",v[19]*v[31]);
  

  	WRITES(cur2,"IsAdopted",v[20]);
  	WRITES(cur2,"Sales_Prod",0);
  	}
  
	if(v[20]==0)// si le produit n'est pas adopte il recupere les perf initiales
  	{
  	WRITES(cur2,"X",v[16]);
  	WRITES(cur2,"Eff",v[17]);
  	WRITES(cur2,"Tox",v[18]);
  	WRITES(cur2,"Bio",v[19]);

  	WRITES(cur2,"IsAdopted",v[20]);
  	WRITES(cur2,"Sales_Prod",0);
  	}
  }
 }

}
else
END_EQUATION(0);


RESULT( v[92]+1)


EQUATION("NbFirms")
/*
nb total de firmes sur le marche
*/

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
{
 	VS(cur,"Budget");//on s'assure que les sorties ont eu lieu (et les entrees)
  v[0]=v[0]+1;
  v[2]=VS(cur,"Entrant");
  v[1]=v[1]+v[2];
}

WRITE("Entrant_Share",v[1]/v[0]);//part de firmes entrantes dans le total

RESULT( v[0])




EQUATION("Delete")
/*
supprime les objets Product_Purchase 
*/

CYCLE(cur, "Firm")
{
 	VS(cur,"Budget");//on s'assure que les sorties ont eu lieu (et les entrees)
  v[0]=VS(cur,"Dead");
  if(v[0]==1)// si la firme est sortie on supprime ses produits
  {
  	v[1]=VS(cur,"IdFirm");
  	CYCLE(cur1, "Product_Purchase")
   {
    v[2]=VS(cur1,"IdFirm_Purchase");
    if(v[1]==v[2])
    DELETE(cur1);
   }
  }
}
RESULT(1 )


EQUATION("Create")
/*
cree les ojets Product_Purchase 
*/

CYCLE(cur, "Firm")
 {  
	v[3]=VS(cur,"NewFirm");
  if(v[3]==1)// si la firme est nouvelle on cree ses produits
  {
  	v[4]=MAX("IdFirm_Purchase");
  	cur2=SEARCH_CND("IdFirm_Purchase", v[4]);//choisi un objet Product_Purchase comme base
  	cur3=ADDOBJ_EX("Product_Purchase",cur2);// cur3 = l'objet cree
  	v[5]=VS(cur,"IdFirm");
  	WRITES(cur3,"IdFirm_Purchase",v[5]);
  	WRITES(cur3,"IdProduct_Purchase",1);
  	
  	v[10]=VS(cur,"Portfolio");
  	WRITES(cur3,"Purchase_Portfolio",v[10]);
  	cur6=SEARCH_CNDS(cur, "IdProduct", 1);//cherche le produit 1 de la firme entrante
  	v[11]=VS(cur6,"X");
  	WRITES(cur3,"Purchase_X",v[11]);
  	v[12]=VS(cur6,"Tox");
  	WRITES(cur3,"Purchase_Tox",v[12]);
  	v[13]=VS(cur6,"Bio");
  	WRITES(cur3,"Purchase_Bio",v[13]);
  	v[14]=VS(cur6,"IsAdopted");
  	WRITES(cur3,"Purchase_IsAdopted",v[14]);
  	WRITES(cur3,"Purchase_MS",0);
  	
  v[30]=V("A_Costs");
  v[31]=V("B_Costs");
  v[32]=V("C_Costs");
  v[33]=V("D_Costs");
  v[34]=VS(cur6,"Eff");
  v[35]=V("Scale_Costs");
  v[36]=VS(cur6,"Markup");
  
  v[37]=(1+v[36])*v[35]*(v[11]-v[30])*(v[31]-v[12])*(v[32]-v[13])*(v[33]-v[34]);//calcul du prix
  WRITES(cur3,"Purchase_Price",v[37]);
  
  	
  	v[6]=MAX("IdFirm_Purchase");
  	cur4=SEARCH_CND("IdFirm_Purchase", v[6]);//choisi un objet Product_Purchase comme base
  	cur5=ADDOBJ_EX("Product_Purchase",cur4);// cur5 = l'objet cree
  	WRITES(cur5,"IdFirm_Purchase",v[5]);
  	WRITES(cur5,"IdProduct_Purchase",2);
  
  	WRITES(cur5,"Purchase_Portfolio",v[10]);
  	cur7=SEARCH_CNDS(cur, "IdProduct", 2);//cherche le produit 2 de la firme entrante
  	v[21]=VS(cur7,"X");
  	WRITES(cur5,"Purchase_X",v[21]);
  	v[22]=VS(cur7,"Tox");
  	WRITES(cur5,"Purchase_Tox",v[22]);
  	v[23]=VS(cur7,"Bio");
  	WRITES(cur5,"Purchase_Bio",v[23]);
  	v[24]=VS(cur7,"IsAdopted");
  	WRITES(cur5,"Purchase_IsAdopted",v[24]);
  	WRITES(cur5,"Purchase_MS",0);
  
  v[44]=VS(cur7,"Eff");
  v[46]=VS(cur7,"Markup");
  
  v[47]=(1+v[46])*v[35]*(v[21]-v[30])*(v[31]-v[22])*(v[32]-v[23])*(v[33]-v[44]);//calcul du prix
  WRITES(cur5,"Purchase_Price",v[47]);
  }
 }

RESULT(1 )


EQUATION("ms_Product1")
/*
Part de march? de la technologie 1
*/
V("EndTrade");
v[0]=V("Total_Households");
v[1]=0;
CYCLE(cur, "Household")
 {
  v[2]=VS(cur,"Product_Type");
  if(v[2]==1)
  v[1]+=1;
 }
v[3]=v[1]/v[0];

RESULT(v[3])




EQUATION("ms_Product2")
/*
Part de march? de la technologie 2
*/
V("EndTrade");
v[0]=V("Total_Households");
v[1]=0;
CYCLE(cur, "Household")
 {
  v[2]=VS(cur,"Product_Type");
  if(v[2]==2)
  v[1]+=1;
 }
v[3]=v[1]/v[0];

RESULT(v[3])




EQUATION("ms_sales")
/*
Part de march? de la firme
*/

v[0]=V("TotalSales");
v[1]=V("Sales");
if(v[0]>0)
 v[2]=v[1]/v[0];
else
 v[2]=0; 
RESULT(v[2])



EQUATION("ms_sales_Product")
/*
Part de march? du produit
*/
v[0]=V("TotalSales");
v[1]=V("Sales_Prod");
if(v[0]>0)
 v[2]=v[1]/v[0];
else
 v[2]=0; 
RESULT(v[2])





EQUATION("TotalSales")
/*
Nombre total de ventes
*/
V("EndTrade");
v[0]=SUM("Sales");

RESULT(v[0] )



EQUATION("Average_K")  

/*
La performance moyenne de l'industrie réalisee sur K 
*/

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")

 { 
   v[2]=VS(cur,"K");
   v[0]=v[0]+v[2];
   v[1]=v[1]+1;
   
 }

v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Average_Sw_Costs")
/*
La performance moyenne de l'industrie réalisée sur swintching_costs  
*/

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")

 { 
   v[2]=VS(cur,"Switching_Costs");
   v[0]=v[0]+v[2];
   v[1]=v[1]+1;
   
  
 }

v[4]=v[0]/v[1];

RESULT(v[4])




/*PROCESSUS D'INNOVATION*/


EQUATION("RD_Budget")
/*
Budget total de RD de la firme
*/

v[0]=V("Budget");
v[1]=V("RDshare");

v[2]=v[1]*v[0];

RESULT(v[2] )




EQUATION("RD1")
/*
RD budget pour le produit 1
*/
V("Adoption_Product2");//on s'assure que le choix de produit a developper est fix?
V("Only_Product2");

v[1]=V("RD_Budget");
v[0]=V("Portfolio");



if(v[0]==2)// developpe que le produit 2
{
	v[2]=0;
}
else
{
	v[3]=V("RD_Split");// part du budget total de RD affectee au produit 1
	v[2]=v[3]*v[1];
}


RESULT( v[2])





EQUATION("RD2")
/*
RD budget pour le produit 2
*/
V("Adoption_Product2");
V("Only_Product2");

v[1]=V("RD_Budget");
v[0]=V("Portfolio");


if(v[0]==0)// developpe que le produit 1
{
	v[2]=0;
}

if(v[0]==1)// developpe les produit 1 et 2
{
	v[3]=V("RD_Split");// part du budget total de RD affectee au produit 1
	v[2]=(1-v[3])*v[1];
}

if(v[0]==2)// developpe que le produit 2
{
	v[2]=v[1];
}

RESULT( v[2])



EQUATION("RD_Watch")
/*
RD de veille techno sur le produit 2
*/
V("Adoption_Product2");
V("Only_Product2");

v[1]=V("RD_Budget");
v[0]=V("Portfolio");


if(v[0]==0)// developpe que le produit 1
{
	v[3]=V("RD_Split");// part du budget total de RD affectee au produit 1
	v[2]=(1-v[3])*v[1];// on affecte l'autre part a la veille
}
else
{
	v[2]=0;
}

RESULT( v[2])



EQUATION("Watch")
/*
veille techno sur le produit 2 : permet d'abaisser les switching costs
*/
V("EndTrade");//veille en fin de periode

v[0]=V("RD_Watch");
v[1]=V("scale");// parametre d'echelle
v[2]=1-exp(-v[0]*v[1]);

v[3]=UNIFORM(0,1);//diminution des switching costs et cumule de cnnaissances
		if(v[3]<=v[2])
		{
		v[4]=V("Switching_Costs");
		v[5]=V("Alpha_Sw_Costs");//Scale parameter
		v[6]=V("Sw_Costsmin");
		WRITE("Switching_Costs",v[4]-v[5]*v[3]*(v[4]-v[6]));// mise ? jour de Costs

		v[7]=V("K");
		v[8]=V("Alpha_K");
		v[9]=V("Kmax");
		WRITE("K",v[7]+v[8]*v[3]*(v[9]-v[7]));// mise ? jour de K
		}

RESULT(1 )


EQUATION("Average_RD_Watch")
/*
RD veille moyenne
*/
v[5]=VL("Average_RD_Watch",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
   v[2]=VS(cur,"RD_Watch");
   if(v[2]!=0)
   {
   	v[0]=v[0]+v[2];
   	v[1]=v[1]+1;
   } 
 }

if(v[1]==0)
v[4]=v[5];
else
v[4]=v[0]/v[1];

RESULT(v[4])





EQUATION("Innovation")
/*
Processus d'innovation
la RD permet d'innover sur chaque dimension
*/
V("EndTrade");//RD en fin de periode
v[30]=V("IdProduct");

if(v[30]==1)// produit de type 1
{
	v[0]=V("RD1");
	v[1]=V("scale");// parametre d'echelle
	v[2]=1-exp(-v[0]*v[1]);

	
	v[3]=UNIFORM(0,1);// innovation sur X

		if(v[3]<=v[2])
		{
		v[4]=V("X");
		v[5]=V("Alpha_X");//Scale parameter
		v[6]=V("Xmax_Prod1");
		WRITE("X",v[4]+v[5]*v[3]*(v[6]-v[4]));// mise ? jour de X
		}
	

	v[13]=UNIFORM(0,1);// innovation sur Tox

		if(v[13]<=v[2])
		{
		v[14]=V("Tox");
		v[15]=V("Alpha_Tox");//Scale parameter
		v[16]=V("Toxmin_Prod1");
		WRITE("Tox",v[14]-v[15]*v[13]*(v[14]-v[16]));// mise ? jour de Tox
		}


		v[23]=UNIFORM(0,1);// innovation sur Eff
		if(v[23]<=v[2])
		{
		v[24]=V("Eff");
		v[25]=V("Alpha_Eff");//Scale parameter
		v[26]=V("Effmax_Prod1");
		WRITE("Eff",v[24]+v[25]*v[23]*(v[26]-v[24]));// mise ? jour de Eff
		}

  		v[33]=UNIFORM(0,1);// innovation sur Bio
		if(v[33]<=v[2])
		{
		v[34]=V("Bio");
		v[35]=V("Alpha_Bio");//Scale parameter
		v[36]=V("Biomin_Prod1");
		WRITE("Bio",v[34]-v[35]*v[33]*(v[34]-v[36]));// mise à jour de Bio
		}
}

if(v[30]==2)// produit de type 2
{
	v[0]=V("RD2");
	v[1]=V("scale");// parametre d'echelle
	v[2]=1-exp(-v[0]*v[1]);
	
	v[3]=UNIFORM(0,1);// innovation sur X

		if(v[3]<=v[2])
		{
		v[4]=V("X");
		v[5]=V("Alpha_X");//Scale parameter
		v[6]=V("Xmax_Prod2");
		WRITE("X",v[4]+v[5]*v[3]*(v[6]-v[4]));// mise ? jour de X
		}
	
		v[13]=UNIFORM(0,1);// innovation sur Tox

		if(v[13]<=v[2])
		{
		v[14]=V("Tox");
		v[15]=V("Alpha_Tox");//Scale parameter
		v[16]=V("Toxmin_Prod2");
		WRITE("Tox",v[14]-v[15]*v[13]*(v[14]-v[16]));// mise ? jour de Tox
		}
	
		v[23]=UNIFORM(0,1);// innovation sur Eff

		if(v[23]<=v[2])
		{
		v[24]=V("Eff");
		v[25]=V("Alpha_Eff");//Scale parameter
		v[26]=V("Effmax_Prod2");
		WRITE("Eff",v[24]+v[25]*v[23]*(v[26]-v[24]));// mise ? jour de Eff
		}

    v[33]=UNIFORM(0,1);// innovation sur Bio

		if(v[33]<=v[2])
		{
		v[34]=V("Bio");
		v[35]=V("Alpha_Bio");//Scale parameter
		v[36]=V("Biomin_Prod2");
		WRITE("Bio",v[34]-v[35]*v[33]*(v[34]-v[36]));// mise à jour de Bio
		}
}

RESULT(1)






EQUATION("Update_Purchase")
/*
Comment
*/
v[0]=V("Update");

RESULT(1 )





FUNCTION("Update")
/*
mise a jour des caracteristiques des produits dans Product_Purchase
Fonction appelee par Update_Purchase pour mise a jour
Mise ? jour en fin de p?riode
*/

CYCLE(cur, "Firm")// on s'assure que chaque firme a fini son processus d'innovation et son choix de technologie
 {
  VS(cur,"Innovation");
  VS(cur,"Adoption_Product2");
  VS(cur,"Only_Product2");
 }

v[0]=VS(c,"IdFirm_Purchase");
v[1]=VS(c,"IdProduct_Purchase");

CYCLE(cur, "Firm")
 {
  v[2]=VS(cur,"IdFirm");
  if(v[2]==v[0])
  {
  	v[15]=VS(cur,"Portfolio");//recupere le portefeuille de la firme
  	CYCLES(cur, cur1, "Product")
   {
    v[3]=VS(cur1,"IdProduct");
    if(v[3]==v[1])
    {
    WRITES(c,"Purchase_Portfolio",v[15]);//ecrit le portefeuille de la firme
    v[4]=VS(cur1,"X");
    WRITES(c,"Purchase_X",v[4]);
    v[5]=VS(cur1,"Tox");
    WRITES(c,"Purchase_Tox",v[5]);
    v[6]=VS(cur1,"Price");
    WRITES(c,"Purchase_Price",v[6]);
    v[7]=VS(cur1,"Bio");
    WRITES(c,"Purchase_Bio",v[7]);
    v[8]=VS(cur1,"IsAdopted");
    WRITES(c,"Purchase_IsAdopted",v[8]);
    v[9]=VS(cur1,"ms_sales_Product");
    WRITES(c,"Purchase_MS",v[9]);
    }
   }

  }
 }
 

RESULT( 1)




EQUATION("Min_Price")
/*
retourne le min sur Price
*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }
 
v[0]=100000000;

CYCLE(cur, "Firm")
 {
 CYCLES(cur, cur1, "Product")
  {
  	v[1]=VS(cur1,"IsAdopted");
  	if(v[1]==1)//Verifie que le produit soit commercialise
   {	
   	v[2]=VS(cur1,"Price");
   	if(v[2]<=v[0])
		v[0]=v[2];
   }
  } 
 }

RESULT(v[0] )



EQUATION("Min_Tox")
/*
retourne le min sur Tox
*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }
 
v[0]=100000000;

CYCLE(cur, "Firm")
 {
 CYCLES(cur, cur1, "Product")
  {
  	v[1]=VS(cur1,"IsAdopted");
  	if(v[1]==1)//Verifie que le produit soit commercialise
   {	
   	v[2]=VS(cur1,"Tox");
   	if(v[2]<=v[0])
		v[0]=v[2];
   }
  } 
 }

RESULT(v[0] )


EQUATION("Min_Bio")
/*
retourne le min sur bio
*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }
 
v[0]=100000000;

CYCLE(cur, "Firm")
 {
 CYCLES(cur, cur1, "Product")
  {
  	v[1]=VS(cur1,"IsAdopted");
  	if(v[1]==1)//Verifie que le produit soit commercialise
   {	
   	v[2]=VS(cur1,"Bio");
   	if(v[2]<=v[0])
		v[0]=v[2];
   }
  } 
 }

RESULT(v[0] )



EQUATION("Max_X")
/*
retourne le max sur X
*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }
 
v[0]=-1000000000;

CYCLE(cur, "Firm")
 {
 CYCLES(cur, cur1, "Product")
  {
  	v[1]=VS(cur1,"IsAdopted");
  	if(v[1]==1)//Verifie que le produit soit commercialise
   {	
   	v[2]=VS(cur1,"X");
   	if(v[2]>=v[0])
		v[0]=v[2];
   }
  } 
 }

RESULT(v[0] )


EQUATION("Average_Costs_T1")
/*
Costs moyen de la techno 1

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=VL("Average_Costs_T1",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=2)//si produit 1 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==1)
  			{			
  				v[2]=VS(cur1,"Costs");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Average_Costs_T2")
/*
Cout moyen de la techno 2

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=VL("Average_Costs_T2",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"Costs");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])


EQUATION("Average_X_T1")
/*
X moyen de la techno 1

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=VL("Average_X_T1",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=2)//si produit 1 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==1)
  			{			
  				v[2]=VS(cur1,"X");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Average_X_T2")
/*
X moyen de la techno 2. !!!! modifi? car pb en cas de reglementation stricte !!!

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=V("Product2_Init_X");// !!!!!!!

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"X");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])


EQUATION("Average_Bio_T1")
/*
Bio moyen de la techno 1

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=VL("Average_Bio_T1",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=2)//si produit 1 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==1)
  			{			
  				v[2]=VS(cur1,"Bio");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Average_Bio_T2")
/*
Bio moyen de la techno 2 !!!! modifi? car pb en cas de reglementation stricte !!!

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=V("Product2_Init_Bio");// !!!!!!!

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"Bio");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])


EQUATION("Average_Tox_T1")
/*
Tox moyen de la techno 1

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=VL("Average_Tox_T1",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=2)//si produit 1 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==1)
  			{			
  				v[2]=VS(cur1,"Tox");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Average_Tox_T2")
/*
Tox moyen de la techno 2. !!!! modifi? car pb en cas de reglementation stricte !!!

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=V("Product2_Init_Tox");// !!!!!!!

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"Tox");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])


EQUATION("Average_Eff_T1")
/*
Eff moyen de la techno 1

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=VL("Average_Eff_T1",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=2)//si produit 1 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==1)
  			{			
  				v[2]=VS(cur1,"Eff");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Average_Eff_T2")
/*
Eff moyen de la techno 2. !!!! modifi? car pb en cas de reglementation stricte !!!

*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }

v[8]=V("Product2_Init_Eff");// !!!!!!!

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"Eff");
   				v[0]=v[0]+v[2];
   				v[1]=v[1]+1;
   			}
  		} 
  	}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])


EQUATION("Markup")
/*
markup endogene
*/
v[0]=V("NewFirm");
if(v[0]==1)//si la firme est un nouvel entrant
{
	v[20]=V("IdProduct");
	if(v[20]==1)//si c'est un produit de type T1
	{
		v[1]=VL("Average_Markup_T1",1);
		v[2]=v[1];
	}
	if(v[20]==2)//si c'est un produit de type T2
	{
		v[1]=VL("Average_Markup_T2",1);
		v[2]=v[1];
	}
}
else
{
	v[3]=VL("Markup",1);

	v[4]=V("IsAdopted");
	if(v[4]==0)// si le produit n'existe pas on garde le markup
	END_EQUATION(v[3]);

	v[5]=V("ms_sales_Product");
	v[6]=V("Inverse_HHI");
	v[7]=V("IdProduct");
	if(v[7]==1)
	{
		v[8]=V("Max_ms_sales_Product_T1");
		v[9]=V("Min_ms_sales_Product_T1");
	}
	if(v[7]==2)
	{
		v[8]=V("Max_ms_sales_Product_T2");
		v[9]=V("Min_ms_sales_Product_T2");
	}

	if(v[8]==v[9])//si monopole ou equirepartition des ms
	v[2]=v[5]+1/v[6];
	else
	v[2]=((v[5]-v[9])/(v[8]-v[9]))+1/v[6];
}

RESULT(v[2] )


EQUATION("Average_Markup_T1")
/*
Comment
*/
V("EndTrade");

v[8]=VL("Average_Markup_T1",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 		CYCLES(cur, cur1, "Product")
  		{		
  			v[2]=VS(cur1,"IdProduct");
  			if(v[2]==1)//verifie que c'est T1
  			{
  				v[3]=VS(cur1,"Markup");
  				v[4]=VS(cur1,"Sales_Prod");
   				v[0]=v[0]+v[3]*v[4];
   				v[1]=v[1]+v[4];
   			}
   		}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4] )



EQUATION("Average_Markup_T2")
/*
Comment
*/
V("EndTrade");

v[8]=VL("Average_Markup_T2",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 		CYCLES(cur, cur1, "Product")
  		{		
  			v[2]=VS(cur1,"IdProduct");
  			if(v[2]==2)//verifie que c'est T2
  			{
  				v[3]=VS(cur1,"Markup");
  				v[4]=VS(cur1,"Sales_Prod");
   				v[0]=v[0]+v[3]*v[4];
   				v[1]=v[1]+v[4];
   			}
   		}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4] )



EQUATION("Max_ms_sales_Product_T1")
/*

*/

v[0]=0;

CYCLE(cur, "Firm")
 {
 CYCLES(cur, cur1, "Product")
  {
  	v[1]=VS(cur1,"IdProduct");
  	if(v[1]==1)//verifie que c'est T1
   {
   	v[2]=VS(cur1,"IsAdopted");//Verifie que le produit soit commercialise
   	if(v[2]==1)
   	{
   		v[3]=VS(cur1,"ms_sales_Product");
   		if(v[3]>=v[0])
			v[0]=v[3];
		}
   }
  } 
 }

RESULT(v[0])


EQUATION("Max_ms_sales_Product_T2")
/*

*/

v[0]=0;

CYCLE(cur, "Firm")
 {
 CYCLES(cur, cur1, "Product")
  {
  	v[1]=VS(cur1,"IdProduct");
  	if(v[1]==2)//verifie que c'est T2
   {
   	v[2]=VS(cur1,"IsAdopted");//Verifie que le produit soit commercialise
   	if(v[2]==1)
   	{
   		v[3]=VS(cur1,"ms_sales_Product");
   		if(v[3]>=v[0])
			v[0]=v[3];
		}
   }
  } 
 }

RESULT(v[0])


EQUATION("Min_ms_sales_Product_T1")
/*

*/

v[0]=1;

CYCLE(cur, "Firm")
 {
 CYCLES(cur, cur1, "Product")
  {
  	v[1]=VS(cur1,"IdProduct");
  	if(v[1]==1)//verifie que c'est T1
   {
   	v[2]=VS(cur1,"IsAdopted");//Verifie que le produit soit commercialise
   	if(v[2]==1)
   	{
   		v[3]=VS(cur1,"ms_sales_Product");
   		if(v[3]<=v[0])
			v[0]=v[3];
		}
   }
  } 
 }

RESULT(v[0])


EQUATION("Min_ms_sales_Product_T2")
/*

*/

v[0]=1;

CYCLE(cur, "Firm")
 {
 CYCLES(cur, cur1, "Product")
  {
  	v[1]=VS(cur1,"IdProduct");
  	if(v[1]==2)//verifie que c'est T2
   {
   	v[2]=VS(cur1,"IsAdopted");//Verifie que le produit soit commercialise
   	if(v[2]==1)
   	{
   		v[3]=VS(cur1,"ms_sales_Product");
   		if(v[3]<=v[0])
			v[0]=v[3];
		}
   }
  } 
 }

RESULT(v[0])


EQUATION("Inverse_HHI")
/*
return the inverse Herfindahl-Hirschman Index
*/
V("EndTrade");


v[0]=0;
CYCLE(cur,"Firm")
{
v[1]=VS(cur,"ms_sales");
v[0]+=v[1]*v[1];
}
if(v[0]==0)
v[2]=0;
else
v[2]=1/v[0];

RESULT(v[2] )


EQUATION("Bio_Acc")
/*
Bioaccumulation
*/
V("EndTrade");

v[0]=VL("Bio_Acc",1);
v[1]=V("Absorption");//capacite d'absorption du milieu

v[5]=0;
CYCLE(cur, "Firm")
 {
	CYCLES(cur, cur1, "Product")
 {
  v[2]=VS(cur1,"Sales_Prod");
  v[3]=VS(cur1,"Bio");
  v[5]=v[5]+v[2]*v[3];
 }
 }

v[6]=v[0]-v[1]+v[5];
if(v[6]<0)
v[7]=0;
else
v[7]=v[6];

RESULT(v[7] )


EQUATION("Tox_Acc")
/*
Indicateur global de toxicite (sante humaine)
*/
V("EndTrade");

v[0]=VL("Tox_Acc",1);
v[1]=V("Toxmin_Prod1");//reflete la dose journaliere admissible

v[5]=0;
CYCLE(cur, "Firm")
 {
	CYCLES(cur, cur1, "Product")
 {
  v[2]=VS(cur1,"Sales_Prod");
  v[3]=VS(cur1,"Tox");
  if(v[3]>=v[1])
  v[5]=v[5]+v[2]*(v[3]-v[1]);
 }
 }

v[6]=v[0]+v[5];
if(v[6]<0)
v[7]=0;
else
v[7]=v[6];

RESULT(v[7] )


EQUATION("Min_TotalHouseholds")
/*
nombre le plus faible de clients atteint au cours de la simu
*/
v[0]=VL("Min_TotalHouseholds",1);
v[1]=V("Total_Households");
if(v[1]<v[0])
v[2]=v[1];
else
v[2]=v[0];

RESULT(v[2] )



EQUATION("Average_Tox")
/*

*/
V("EndTrade");

v[8]=VL("Average_Tox",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 		CYCLES(cur, cur1, "Product")
  		{		
  				v[2]=VS(cur1,"Tox");
  				v[3]=VS(cur1,"Sales_Prod");
   				v[0]=v[0]+v[2]*v[3];
   				v[1]=v[1]+v[3];
   		}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])


EQUATION("Average_Bio")
/*

*/
V("EndTrade");

v[8]=VL("Average_Bio",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 		CYCLES(cur, cur1, "Product")
  		{		
  				v[2]=VS(cur1,"Bio");
  				v[3]=VS(cur1,"Sales_Prod");
   				v[0]=v[0]+v[2]*v[3];
   				v[1]=v[1]+v[3];
  		} 
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Average_Costs")
/*

*/
V("EndTrade");

v[8]=VL("Average_Costs",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 		CYCLES(cur, cur1, "Product")
  		{		
  				v[2]=VS(cur1,"Costs");
  				v[3]=VS(cur1,"Sales_Prod");
   				v[0]=v[0]+v[2]*v[3];
   				v[1]=v[1]+v[3];
   		}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])



EQUATION("Average_X")
/*

*/
V("EndTrade");

v[8]=VL("Average_X",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 		CYCLES(cur, cur1, "Product")
  		{		
  				v[2]=VS(cur1,"X");
  				v[3]=VS(cur1,"Sales_Prod");
   				v[0]=v[0]+v[2]*v[3];
   				v[1]=v[1]+v[3];
   		}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])


EQUATION("Average_Eff")
/*

*/
V("EndTrade");

v[8]=VL("Average_Eff",1);

v[0]=0;
v[1]=0;

CYCLE(cur, "Firm")
 {
 		CYCLES(cur, cur1, "Product")
  		{		
  				v[2]=VS(cur1,"Eff");
  				v[3]=VS(cur1,"Sales_Prod");
   				v[0]=v[0]+v[2]*v[3];
   				v[1]=v[1]+v[3];
   		}
 }

if(v[1]==0)
v[4]=v[8];
else
v[4]=v[0]/v[1];

RESULT(v[4])
  
  
EQUATION("Absolute_maxX_P2")
/*
valeur de X la plus eleve jusqu'a present pour le produit 2
*/

CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }
 
v[0]=VL("Absolute_maxX_P2",1);

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"X");
   				if(v[2]>v[0])
   				v[0]=v[2];
   			}
  		} 
  	}
 }

RESULT(v[0] )


EQUATION("Absolute_maxEff_P2")
/*
valeur de Eff la plus forte jusqu'a present pour le produit 2
*/
CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }
 
v[0]=VL("Absolute_maxEff_P2",1);

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"Eff");
   				if(v[2]>v[0])
   				v[0]=v[2];
   			}
  		} 
  	}
 }

RESULT(v[0] )


EQUATION("Absolute_minTox_P2")
/*
valeur de Tox la plus faible jusqu'a present pour le produit 2
*/

CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }
 
v[0]=VL("Absolute_minTox_P2",1);

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"Tox");
   				if(v[2]<v[0])
   				v[0]=v[2];
   			}
  		} 
  	}
 }

RESULT(v[0] )


EQUATION("Absolute_minBio_P2")
/*
valeur de Bio la plus faible jusqu'a present pour le produit 2
*/

CYCLE(cur, "Firm")//on s'assure que le processus d'innovation a eu lieu
 {
  VS(cur,"Innovation");
 }
 
v[0]=VL("Absolute_minBio_P2",1);

CYCLE(cur, "Firm")
 {
 	v[5]=VS(cur,"Portfolio");
 	if(v[5]!=0)//si produit 2 adopte
 	{
 		CYCLES(cur, cur1, "Product")
  		{
  			v[7]=VS(cur1,"IdProduct");
  			if(v[7]==2)
  			{			
  				v[2]=VS(cur1,"Bio");
   				if(v[2]<v[0])
   				v[0]=v[2];
   			}
  		} 
  	}
 }

RESULT(v[0] )


/*EQUATIONS REGLEMENTATION*/

EQUATION("Regulation")
/*
0 si non appliquee, 1 si appliquee (= T1 est interdite)
*/
v[0]=V("Sunset_Date");
v[1]=V("Revision_Period");

if(t==(v[0]+v[1]))
{	
	v[2]=VL("Average_Eff_T2",1);
	v[3]=VL("Average_X_T2",1);
	v[4]=V("Target_Eff");
	v[5]=V("Target_X");

	if(v[2]>=v[4]&&v[3]>=v[5])//si les seuils sont satisfaits on interdit le produit 1
	{
		v[6]=1;
		WRITE("ExitP1_Date",t);// enregistre la periode a laquelle le produit 1 est interdit
		PARAMETER;
	}
	else
	{
		v[6]=0;
		v[7]=V("Revision_Period_Update");// mise a jour de la periode de revision
		INCR("Revision_Period",v[7]);
	}
}
else
v[6]=0;

RESULT( v[6])


/*EQUATIONS D'INITIALISATION*/


EQUATION("EndTrade")
/*
S'assure que chaque client a effectu? son processus d'achat
*/
CYCLE(cur, "Household")
 VS(cur,"ProdUsed");

RESULT( 1)


EQUATION("InitTrade")
/*
Initialise la valeur des attributs des firmes au d?but de chaque p?riode
*/

CYCLE(cur, "Firm")
 { 
 	WRITES(cur,"NewFirm",0);
  WRITES(cur,"Sales",0);
   CYCLES(cur,cur1, "Product")
    {
     WRITES(cur1,"Sales_Prod",0);
    }
}

V("Enter");//on lance le processus d'entree
V("Create");//on cree les objets Product_Purchase de l'entrant


RESULT(1 )


EQUATION("Total_Households")
/*
compte le nb de clients
*/
v[1]=0;
CYCLE(cur, "Household")
 {
  v[0]=VS(cur,"ProdUsed");
  if(v[0]!=0)//si le client a un produit
  v[1]=v[1]+1;
 }
 
if(v[1]<200)
INCR("Low_Demand_Time",1);//etendue temporelle de la baisse du nb de clients

RESULT( v[1])



EQUATION("Reservation_Price")
/*
prix de reserve des clients!!!! A MODIFIER
*/

v[0]=UNIFORM(97,715);

PARAMETER;

RESULT( v[0])



EQUATION("Reservation_X")
/*
seuil d'exigence min de X des clients
*/

v[0]=UNIFORM(3,9);
PARAMETER;

RESULT( v[0])



EQUATION("a")
/*

*/
v[0]=UNIFORM(0,1);
PARAMETER;

RESULT( v[0])


EQUATION("b")
/*

*/
v[0]=UNIFORM(0,1);
PARAMETER;

RESULT( v[0])


EQUATION("c")
/*

*/
v[0]=UNIFORM(0,1);
PARAMETER;

RESULT( v[0])


EQUATION("d")
/*

*/

v[0]=UNIFORM(0,1);
PARAMETER;

RESULT( v[0])


EQUATION("e")
/*

*/

v[0]=UNIFORM(0.05,0.05);
PARAMETER;

RESULT( v[0])



EQUATION("RD_Split_Index")
/*
Part de la R&D affectée a T1 sans tenir compte de la reglementation
*/

v[0]=UNIFORM(0,1);
PARAMETER;

RESULT( v[0])



EQUATION("RD_Split")
/*
Part de la R&D affectée a T1 en tenant compte de la reglementation
*/

v[1]=V("RD_Split_Index");
v[2]=V("Alpha_Regu");
v[3]=V("Sunset_Date");
v[6]=V("Revision_Period");


v[0]=v[1]*(1-v[2]*t/(v[3]+v[6]));

RESULT( v[0])



EQUATION("Adoption_Threshold_MS")//!!!!
/*

*/

v[0]=UNIFORM(-1,1);//!!!!!!!
PARAMETER;

RESULT( v[0])


EQUATION("Adoption_Threshold_K")//!!!!
/*

*/

v[0]=UNIFORM(0,1);
PARAMETER;

RESULT( v[0])


EQUATION("Threshold_Abandon")
/*
seuil de part du produit 2 dans le CA a atteindre pour abandonner le produit 1
*/

v[0]=UNIFORM(0.5,1);
PARAMETER;

RESULT( v[0])


EQUATION("Alpha_Regu_Households")
/*
parametre de credibite de la reglementation aux yeux des clients
*/
v[0]=V("Benchmark");//controle si la configuration est le benchmark ou pas
if(v[0]==1)
v[1]=0;
else
v[1]=UNIFORM(0,1);
PARAMETER;

RESULT(v[1] )


EQUATION("Alpha_Regu")
/*
parametre de credibite de la reglementation aux yeux des firmes
*/
v[0]=V("Benchmark");//controle si la configuration est le benchmark ou pas
if(v[0]==1)
v[1]=0;
else
v[1]=UNIFORM(0,1);
PARAMETER;

RESULT(v[1] )


MODELEND

// **Définition globale de la fonction fun**
/*double fun(object *caller) {
    srand(time(nullptr));
    model.initializeFirms();
    model.initializeHouseholds();
    model.displayHouseholds();

    return 0;
}*/


double fun(object* caller) {  // Fonction de retour double
    srand(time(nullptr));

    Model model;  // Création de l'instance de Model

    model.initializeFirms();   // Initialisation des firmes
    model.initializeHouseholds();   // Initialisation des ménages
    model.displayHouseholds();  // Affichage des ménages

    return 0.0;  // Retourne un double, par exemple 0.0 ici
}




/*
int main() {
    srand(time(NULL));

    for (int i = 0; i < numFirms; ++i) {
        firms[i].sector = sectors[i % 6];
    }

    initializeHouseholds();

    for (int i = 0; i < 10; ++i) {
        std::cout << "Household " << i
                  << " -> Status: " << households[i].status
                  << ", Sector: " << sectors[households[i].assignedSector]
                  << ", Salary: " << households[i].salary << "\n";
    }

    return 0;
}
*/


void close_sim(void)
{

}



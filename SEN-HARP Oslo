import pandas as pd
import numpy as np
import random
import time
import matplotlib.pyplot as plt
import seaborn as sns
import math

# D√©but du chronom√®tre
start_time = time.time()

# Param√®tres du mod√®le
sectors = ["Agriculture", "Energy", "Housing", "Transport", "Industry", "Technology"]
num_firms = 120
num_banks = 10
num_households = 600
num_centralbank = 1
num_periods = 25
num_simulations = 5

# Initialisation structurelle des 600 m√©nages
random.seed(42)
np.random.seed(42)

# === Bloc 1 : Initialisation des param√®tres biophysiques ===

params = {
    # Coefficients de cycle du carbone
    "phi_11": 0.6,
    "phi_21": 0.25,
    "phi_12": 0.35,
    "phi_22": 0.45,
    "phi_32": 0.1,
    "phi_23": 0.15,
    "phi_33": 0.7,
    
    # For√ßage radiatif
    "RF_2CO2": 3.7,
    
    # Concentration CO2 pr√©-industrielle (ppm)
    "AtmosphericPreIndustrialCO2Concentration": 280,
    
    # Sensibilit√© climatique (¬∞C)
    "CS": 3.0,
    
    # Coefficients temps (discr√©tisation temp√©rature)
    "t_1": 0.2,
    "t_2": 0.1,
    "t_3": 0.05,
    
    # Coefficients fonction dommages climatiques
    "eta_1": 0.01,
    "eta_2": 0.005,
    "eta_3": 0.0001,
    
    # Emissions industrielles : part √©nergie non renouvelable
    "emissions_share": 0.8,
    
    # Changement d'usage des sols (taux de d√©clin √©missions terres)
    "land_use_change": 0.01,

    "epsilon_V": 0.1,  # Exemple valeur : intensit√© √©nerg√©tique faible pour capital vert
    "epsilon_B": 0.3,  # Exemple valeur : intensit√© √©nerg√©tique plus √©lev√©e pour capital brun
}

# Initialisation des variables biophysiques sur toute la dur√©e des p√©riodes
# (√† adapter au nombre total de p√©riodes de ta simulation)
num_periods = 25  # ou r√©cup√®re la valeur r√©elle de ton mod√®le

nature = {
    "AtmosphericCO2Concentration": [params["AtmosphericPreIndustrialCO2Concentration"]] * num_periods,
    "BiosphereCO2Concentration": [150] * num_periods,  # estimation initiale
    "LowerOceansCO2Concentration": [90] * num_periods,  # estimation initiale
    "IndustrialEmissions": [0.0] * num_periods,
    "LandUseEmissions": [0.0] * num_periods,
    "TotalEmissions": [0.0] * num_periods,
    "AtmosphericTemperature": [14.0] * num_periods,  # ¬∞C absolue ou anomaly selon ton mod√®le
    "LowerOceansTemperature": [3.0] * num_periods,
    "RadiativeForcing": [0.0] * num_periods,
    "DamagesFunction": [0.0] * num_periods,
}


    # Part de consommation normalis√©e par secteur pour les territoires ruraux
rural_prefs = {
    "AgPref": 0.24,
    "EnerPref": 0.19,
    "HousPref": 0.19,
    "TransPref": 0.24,
    "IndPref": 0.09,
    "TCPref": 0.05
}

# Part de consommation normalis√©e par secteur pour les territoires urbains
urban_prefs = {
    "AgPref": 0.21,
    "EnerPref": 0.16,
    "HousPref": 0.29,
    "TransPref": 0.19,
    "IndPref": 0.1,
    "TCPref": 0.05
}

# Initialisation des 600 m√©nages avec statut, comp√©tences et pr√©f√©rences
households_struct = []

# Statuts 1, 2 : emploi brun/vert non qualifi√©
for _ in range(171):
    status, skill = 1, 0
    id_territory = np.random.choice([0, 1])
    prefs = rural_prefs if id_territory == 0 else urban_prefs
    h = {"Status": status, "SkillStatus": skill, "IdTerritory": id_territory}
    h.update(prefs)
    households_struct.append(h)

for _ in range(179):
    status, skill = 2, 0
    id_territory = np.random.choice([0, 1])
    prefs = rural_prefs if id_territory == 0 else urban_prefs
    h = {"Status": status, "SkillStatus": skill, "IdTerritory": id_territory}
    h.update(prefs)
    households_struct.append(h)

# Statut 3 : ch√¥mage (non qualifi√©)
for _ in range(44):
    status, skill = 3, 0
    id_territory = np.random.choice([0, 1])
    prefs = rural_prefs if id_territory == 0 else urban_prefs
    h = {"Status": status, "SkillStatus": skill, "IdTerritory": id_territory}
    h.update(prefs)
    households_struct.append(h)

# Statut 3 : ch√¥mage (qualifi√©)
for _ in range(16):
    status, skill = 3, 1
    id_territory = np.random.choice([0, 1])
    prefs = rural_prefs if id_territory == 0 else urban_prefs
    h = {"Status": status, "SkillStatus": skill, "IdTerritory": id_territory}
    h.update(prefs)
    households_struct.append(h)

# Statuts 5, 6 : emploi brun/vert qualifi√©
for _ in range(89):
    status, skill = 5, 1
    id_territory = np.random.choice([0, 1])
    prefs = rural_prefs if id_territory == 0 else urban_prefs
    h = {"Status": status, "SkillStatus": skill, "IdTerritory": id_territory}
    h.update(prefs)
    households_struct.append(h)

for _ in range(101):
    status, skill = 6, 1
    id_territory = np.random.choice([0, 1])
    prefs = rural_prefs if id_territory == 0 else urban_prefs
    h = {"Status": status, "SkillStatus": skill, "IdTerritory": id_territory}
    h.update(prefs)
    households_struct.append(h)

# M√©lange al√©atoire pour √©viter les biais
random.shuffle(households_struct)

# IdTerritory (0 = rural, 1 = urbain)
for h in households_struct:
    h["IdTerritory"] = np.random.choice([0, 1])

# IdEmployer : si emploi, alors affectation √† une firme
for h in households_struct:
    if h["Status"] in [1, 2, 5, 6]:
        h["IdEmployer"] = random.randint(0, num_firms - 1)
    else:
        h["IdEmployer"] = -1

general_inflation = [0.02 for _ in range(num_periods)]
price_ag_list = [1.0]
price_ener_list = [1.0]
price_hous_list = [1.0]
price_trans_list = [1.0]
CarbonTaxActive = []
TransitionActive = []
PostGrowthActive = []
growth_v = [0.01]  # croissance verte initiale pour t = 0
brown_loan_cap = [1.0]  # autorisation initiale √† 100%
gdp_records = []
needsindex_records = []
social_cost_records = []
status_share_records = []
policy_outcomes = []
policy_records = []
household_records = []
vote_records = []

is_carbon_tax_scenario = False

def compute_firm_energy_intensity(firm, t, epsilon_V, epsilon_B):
    green_cap = firm["GreenCapital"][t] if t < len(firm["GreenCapital"]) else 0
    brown_cap = firm["BrownCapital"][t] if t < len(firm["BrownCapital"]) else 0
    total_cap = green_cap + brown_cap
    green_ratio = green_cap / total_cap if total_cap > 0 else 0
    intensity = green_ratio * epsilon_V + (1 - green_ratio) * epsilon_B
    return intensity

def update_biophys_vars(nature, firms, t, params):
    import math

    # R√©cup√©ration des valeurs historiques
    CO2_prev = nature["AtmosphericCO2Concentration"][t-1] if t > 0 else nature["AtmosphericCO2Concentration"][0]
    Biosphere_CO2_prev = nature["BiosphereCO2Concentration"][t-1] if t > 0 else nature["BiosphereCO2Concentration"][0]
    LowerOceans_CO2_prev = nature["LowerOceansCO2Concentration"][t-1] if t > 0 else nature["LowerOceansCO2Concentration"][0]
    Temp_Atmos_prev = nature["AtmosphericTemperature"][t-1] if t > 0 else nature["AtmosphericTemperature"][0]
    Temp_Oceans_prev = nature["LowerOceansTemperature"][t-1] if t > 0 else nature["LowerOceansTemperature"][0]

    # Calcul des √©missions industrielles cumul√©es sur les firmes
    industrial_emissions = 0
    for firm in firms:
        # Calcul micro√©conomique de l'intensit√© √©nerg√©tique
        green_cap = firm["GreenCapital"][t] if t < len(firm["GreenCapital"]) else 0
        brown_cap = firm["BrownCapital"][t] if t < len(firm["BrownCapital"]) else 0
        total_cap = green_cap + brown_cap
        green_ratio = green_cap / total_cap if total_cap > 0 else 0

        epsilon_V = params["epsilon_V"]
        epsilon_B = params["epsilon_B"]
        energy_intensity = green_ratio * epsilon_V + (1 - green_ratio) * epsilon_B

        production = firm["Production"][t] if t < len(firm["Production"]) else 0
        energy_needed = energy_intensity * production

        renewable_share = 1 / (1 + 1/(0.54 * green_ratio)) if green_ratio > 0 else 0
        renewable_energy = renewable_share * energy_needed
        non_renewable_energy = energy_needed - renewable_energy

        emissions_share = params["emissions_share"]
        industrial_emissions += emissions_share * non_renewable_energy

    nature["IndustrialEmissions"][t] = industrial_emissions

    # Emissions li√©es √† l'usage des sols
    land_use_change = params.get("land_use_change", 0.01)
    if t == 0:
        nature["LandUseEmissions"][t] = 0
    else:
        nature["LandUseEmissions"][t] = nature["LandUseEmissions"][t-1] * (1 - land_use_change)

    # Total emissions
    nature["TotalEmissions"][t] = nature["IndustrialEmissions"][t] + nature["LandUseEmissions"][t]

    # Concentrations CO2 atmosph√©rique et autres r√©servoirs
    phi_11 = params["phi_11"]
    phi_21 = params["phi_21"]
    phi_12 = params["phi_12"]
    phi_22 = params["phi_22"]
    phi_32 = params["phi_32"]
    phi_23 = params["phi_23"]
    phi_33 = params["phi_33"]

    nature["AtmosphericCO2Concentration"][t] = nature["TotalEmissions"][t] + phi_11 * CO2_prev + phi_21 * Biosphere_CO2_prev
    nature["BiosphereCO2Concentration"][t] = phi_12 * CO2_prev + phi_22 * Biosphere_CO2_prev + phi_32 * LowerOceans_CO2_prev
    nature["LowerOceansCO2Concentration"][t] = phi_23 * Biosphere_CO2_prev + phi_33 * LowerOceans_CO2_prev

    # Radiative forcing
    RF_2CO2 = params["RF_2CO2"]
    CO2_preindustrial = params["AtmosphericPreIndustrialCO2Concentration"]
    ratio = nature["AtmosphericCO2Concentration"][t] / CO2_preindustrial if CO2_preindustrial > 0 else 1
    if ratio > 0:
        radiative_forcing = math.log(RF_2CO2 * ratio) / math.log(2)
    else:
        radiative_forcing = 0
    nature["RadiativeForcing"] = radiative_forcing

    # Temp√©rature atmosph√©rique
    CS = params["CS"]
    t_1 = params["t_1"]
    t_2 = params["t_2"]
    RF = radiative_forcing
    part = RF - (RF_2CO2 / CS)
    temp_inter = part * Temp_Atmos_prev - t_2 * (Temp_Atmos_prev - Temp_Oceans_prev)
    nature["AtmosphericTemperature"][t] = t_1 * temp_inter

    # Temp√©rature oc√©ans profonds
    t_3 = params["t_3"]
    nature["LowerOceansTemperature"][t] = Temp_Oceans_prev + t_3 * (Temp_Atmos_prev - Temp_Oceans_prev)

    # Fonction dommages climatiques
    eta_1 = params["eta_1"]
    eta_2 = params["eta_2"]
    eta_3 = params["eta_3"]
    T_at = nature["AtmosphericTemperature"][t]
    damages = eta_1 * T_at + eta_2 * (T_at ** 2) + eta_3 * (T_at ** 6.754)
    nature["DamagesFunction"][t] = 1 - 1 / (1 + damages)

def plot_climate_variables(nature, num_periods, scenario_name):
    # Pr√©parer un DataFrame pour seaborn
    data = {
        "Period": list(range(num_periods)),
        "AtmosphericTemperature": nature["AtmosphericTemperature"][:num_periods],
        "LowerOceansTemperature": nature["LowerOceansTemperature"][:num_periods],
        "AtmosphericCO2Concentration": nature["AtmosphericCO2Concentration"][:num_periods],
        "TotalEmissions": nature["TotalEmissions"][:num_periods],
    }
    df = pd.DataFrame(data)
    df = df.melt(id_vars="Period", var_name="Variable", value_name="Value")

    plt.figure(figsize=(12, 6))
    sns.lineplot(data=df, x="Period", y="Value", hue="Variable")
    plt.title(f"√âvolution climatique dans le sc√©nario {scenario_name}")
    plt.xlabel("P√©riode")
    plt.ylabel("Valeurs")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

def gini_coefficient(x):
    import numpy as np
    sorted_x = np.sort(np.array(x))
    n = len(x)
    cumx = np.cumsum(sorted_x)
    sum_x = cumx[-1]
    if sum_x == 0:
        return 0
    gini = (n + 1 - 2 * np.sum(cumx) / sum_x) / n
    return gini

def update_policy_activation(t, household_list, policy_list, scenario_triggered):
    if t == 0:
        policy_list.append(0)
    elif t in [5, 10, 15, 20, num_periods - 1] and scenario_triggered:
        # V√©rifie que tous les m√©nages ont bien un vote pour t
        if all(len(h["VoteDecision"]) > t for h in household_list):
            nb_pro = sum(1 for h in household_list if h["VoteDecision"][t] == 1)
            policy_list.append(1 if nb_pro > num_households // 2 else 0)
        else:
            # Si pas encore de vote pour t, prolonge la derni√®re valeur
            policy_list.append(policy_list[t - 1])
    else:
        policy_list.append(policy_list[t - 1])

def compute_firm_revenues_and_profits(t, firm_list, household_list, CarbonTaxActive):
    sectors = ["Agriculture", "Energy", "Housing", "Transport", "Industry", "Technology"]
    supp_keys = ["SuppConsAg", "SuppConsEner", "SuppConsHous", "SuppConsTrans", "SuppConsInd", "SuppConsTC"]
    pref_keys = ["AgPref", "EnerPref", "HousPref", "TransPref", "IndPref", "TCPref"]

    # 1. Agr√©gation des consommations sectorielles
    sector_revenue = {sector: 0.0 for sector in sectors}

    for h in household_list:
        base_c = h["BaseConsumption"][t] if len(h["BaseConsumption"]) > t else 0
        for i, sector in enumerate(sectors):
            base_share = base_c * h.get(pref_keys[i], 0)
            supp_share = h[supp_keys[i]][t] if supp_keys[i] in h and len(h[supp_keys[i]]) > t else 0
            sector_revenue[sector] += base_share + supp_share

    # Debug : affichage des revenus sectoriels
    print(f"[t={t}] Revenus sectoriels :")
    for k, v in sector_revenue.items():
        print(f" - {k} : {v:.2f}")

    # 2. R√©partition aux firmes
    firms_by_sector = {s: [] for s in sectors}
    for f in firm_list:
        sector_name = sectors[f["IdSector"] - 1]
        firms_by_sector[sector_name].append(f)

    for sector in sectors:
        firms = firms_by_sector[sector]
        total_rev = sector_revenue[sector]
        if not firms:
            continue
        rev_per_firm = total_rev / len(firms)
        for f in firms:
            if "Revenue" not in f:
                f["Revenue"] = [0.0] * t
            while len(f["Revenue"]) <= t:
                f["Revenue"].append(0.0)
            f["Revenue"][t] = rev_per_firm
            print(f"  ‚Üí Firm {f['FirmID']} ({sector}) re√ßoit revenu {rev_per_firm:.2f}")

    # 3. Profits
    for f in firm_list:
        revenue = f["Revenue"][t] if "Revenue" in f and len(f["Revenue"]) > t else 0
        firm_id = f["FirmID"]
        wages_paid = 0.0
        for h in household_list:
            if h.get("IdEmployer", -1) != firm_id:
                continue
            status = h.get("Status", -1)
            if status == 1:
                wages_paid += f["LowSkilledBrownWage"][t] if len(f["LowSkilledBrownWage"]) > t else 0
            elif status == 2:
                wages_paid += f["LowSkilledGreenWage"][t] if len(f["LowSkilledGreenWage"]) > t else 0
            elif status == 4:
                wages_paid += f["HighSkilledBrownWage"][t] if len(f["HighSkilledBrownWage"]) > t else 0
            elif status == 5:
                wages_paid += f["HighSkilledGreenWage"][t] if len(f["HighSkilledGreenWage"]) > t else 0

        brown_loans = f["BrownLoans"][t - 1] if t > 0 and len(f["BrownLoans"]) > t - 1 else 0
        green_loans = f["GreenLoans"][t - 1] if t > 0 and len(f["GreenLoans"]) > t - 1 else 0
        loan_rate = f["LoanInterestRate"][t] if len(f["LoanInterestRate"]) > t else 0.02
        green_rate = f["GreenLoanInterestRate"][t] if len(f["GreenLoanInterestRate"]) > t else 0.015
        interest_paid = loan_rate * brown_loans + green_rate * green_loans
        carbon_tax = 0.05 * f["BrownCapital"][t] if len(CarbonTaxActive) > t and CarbonTaxActive[t] == 1 else 0
        profit = revenue - wages_paid - interest_paid - carbon_tax

        f.setdefault("Profits", [])
        while len(f["Profits"]) <= t:
            f["Profits"].append(0.0)
        f["Profits"][t] = profit


# Liste pour stocker tous les r√©sultats
gini_records = []
all_results = []

# Simulation
for sim in range(num_simulations):
    max_brown_credit = 1.0  # 100% de capacit√© initialement
    scenario_names = ["carbon_tax_only", "transition_mix", "post_growth"]
    scenario_name = scenario_names[sim % len(scenario_names)]
    scenario = sim % len(scenario_names) + 1  # 1: carbon_tax_only, 2: transition_mix, 3: post_growth


    # Initialisation des politiques
    carbon_tax_active = False
    transition_policy_active = False
    post_growth_policy_active = False

    if scenario_name in ["carbon_tax_only", "transition_mix"]:
        carbon_tax_active = True
    elif scenario_name == "transition_mix":
        transition_policy_active = True
    elif scenario_name == "post_growth":
        post_growth_policy_active = True

    firm_list = []
    for i in range(num_firms):
        firm = {
            "FirmID": i,
            "ProductivityFactor": random.uniform(0.0, 0.3),
            "IdBank": random.randint(0, num_banks - 1),
            "BrownCapital": [random.uniform(50, 150)],
            "GreenCapital": [random.uniform(25, 100)],
            "BrownInvestment": [],
            "GreenInvestment": [],
            "BrownInvDes": [],
            "GreenInvDes": [],
            "BrownLoansDem": [],
            "GreenLoansDem": [],
            "BrownLoansVar": [],
            "GreenLoansVar": [],
            "Profits": [random.uniform(20, 100)],
            "TotalDebt": [random.uniform(50, 300)],
            "LoanInterestRate": [],
            "GreenLoanInterestRate": [],
            "AnimalSpirits_B": [],
            "AnimalSpirits_V": [],
            "gamma1": [],
            "gamma2": [],
            "gamma3": [],
            "gamma4": [],
            "GrKdB": [0],
            "GrKdV": [0],
            "ratiocashflow": [],
            "LeverageFirm": [],
            "FullCapacityProduction": [],
            "BrownLoans": [],
            "GreenLoans": [],
            "CreditConstraintVar": [],
            "CreditConstraintInt": [],
            "TotalCapital": [],
            "GreenCapitalRatio": [],
            "IdSector": sectors.index(sectors[i % len(sectors)]) + 1,
            "SelectedChampions": 1 if random.random() < 0.2 else 0,  # 20% des firmes sont champions
            "Production": [0]*num_periods,

        }
        firm_list.append(firm)

    bank_list = []
    for b in range(num_banks):
        bank = {
            "BankID": b,
            "TargetLeverage": [],
            "BanksAnimalSpirits": [],
            "Failures": [random.randint(0, 3)],
            "RiskAppetite": [],
            "GreenLoansBank": [],
            "BrownLoansBank": [],
            "GreenAssetRatio": [],
            "BankLoans": [],
            "MarketShareBank": [],
        }
        bank_list.append(bank)

    # Initialisation compl√®te des m√©nages
    household_list = []
    for h in households_struct:
        income_init = random.uniform(20, 50)
        savings_init = random.uniform(10, 40)

        # Pr√©f√©rences selon le territoire
        prefs = rural_prefs if h["IdTerritory"] == 0 else urban_prefs

        household = {
            "Status": h["Status"],
            "SkillStatus": h["SkillStatus"],
            "IdTerritory": h["IdTerritory"],
            "IdEmployer": h["IdEmployer"],
            "AgPref": h["AgPref"],
            "EnerPref": h["EnerPref"],
            "HousPref": h["HousPref"],
            "TransPref": h["TransPref"],
            "IndPref": h["IndPref"],
            "TCPref": h["TCPref"],
            "DisposableIncome": [income_init],
            "Income": [income_init],
            "FinancialIncome": [0.01 * savings_init],
            "Red": [random.uniform(2, 5)],
            "TaxesInd": [0.2 * income_init],
            "HouseholdDebtService": [0.03 * random.uniform(10, 40)],
            "LoanRateCons": [0.03],
            "HouseholdNewDebt": [0],
            "HouseholdTotalDebt": [random.uniform(10, 40)],
            "BaseConsumption": [random.uniform(25, 35)],
            "Consumption": [random.uniform(20, 45)],
            "Savings": [savings_init],
            "DepositInterestRate": [0.01],
            "TaxRate": [0.2],
            "PropensityToConsumeDI": [0.6],
            "PropensityToConsumeSavings": [0.3],
            "NeedsIndex": [100.0],
            "GrNeedsIndex": [],
            "VoteDecision": [random.randint(0, 1)],
            "DistanceToJob": random.uniform(3, 7) if h["IdTerritory"] == 0 else random.uniform(0.5, 3),


        }
        household_list.append(household)


    central_bank_rate = [0.02] * num_periods
    bandwagon_effect = []
    TransitionActive = []
    minimum_wage = [20]
    unemployment_benefit = [12]
    base_wage = 20
    green_premium = 0.05
    skill_premium = 0.25
    green_skill_premium = 0.30
    firms_by_bank = {b: [] for b in range(num_banks)}
    for firm in firm_list:
        firms_by_bank[firm["IdBank"]].append(firm)


    for t in range(num_periods):
    # üîí S√©curisation explicite de SuppCons et BaseConsumption
        for h in household_list:
            if "SuppCons" not in h:
                h["SuppCons"] = [0.0] * (t + 1)
            elif len(h["SuppCons"]) <= t:
                h["SuppCons"].extend([0.0] * (t + 1 - len(h["SuppCons"])))
            if "BaseConsumption" not in h:
                h["BaseConsumption"] = [0.0] * (t + 1)
            elif len(h["BaseConsumption"]) <= t:
                h["BaseConsumption"].extend([0.0] * (t + 1 - len(h["BaseConsumption"])))


        update_policy_activation(t, household_list, CarbonTaxActive, scenario == 1)
        update_policy_activation(t, household_list, TransitionActive, scenario == 2)
        update_policy_activation(t, household_list, PostGrowthActive, scenario == 3)
        # R√©duction progressive de la capacit√© de pr√™ts verts
        if scenario == "post_growth" and t > 0:
            max_brown_credit = max(0.0, max_brown_credit * 0.8)

        if t == 0:
            brown_loan_cap.append(1.0)  # Autorisation initiale √† 100%
        else:
            if PostGrowthActive[t] == 1:
                brown_loan_cap.append(max(0, brown_loan_cap[t - 1] - 0.20))
            else:
                brown_loan_cap.append(brown_loan_cap[t - 1])
        
        if t < 2:
            bandwagon_effect.append(0.0)
        else:
            n_0to1 = 0
            n_1to0 = 0

            for household in household_list:
                vote_t2 = household["VoteDecision"][t - 2]
                vote_t1 = household["VoteDecision"][t - 1]
                if vote_t2 == 0 and vote_t1 == 1:
                    n_0to1 += 1
                if vote_t2 == 1 and vote_t1 == 0:
                    n_1to0 += 1

            net_shift = n_0to1 - n_1to0
            bandwagon = net_shift / num_households
            bandwagon_effect.append(bandwagon)


        if t == 0:
            minimum_wage = [20]
        else:
            prev_wage = minimum_wage[t - 1]
            increase_rate = 0.02 if TransitionActive[t - 1] == 1 else 0.0
            new_wage = prev_wage * (1 + increase_rate)
            minimum_wage.append(new_wage)

        if t == 0:
            unemployment_benefit = [15]
        else:
            prev_ub = unemployment_benefit[t - 1]
            ub_increase_rate = 0.02 if TransitionActive[t - 1] == 1 else 0.0
            new_ub = prev_ub * (1 + ub_increase_rate)
            unemployment_benefit.append(new_ub)


# === NOUVEAU BLOC : Production dynamique et demande d'emploi fluctuante ===

        for firm in firm_list:
                    # --- 1. Production d√©pendante du capital total ---
            green_capital = firm.get("GreenCapital", [0])[t - 1] if t > 0 else 0
            brown_capital = firm.get("BrownCapital", [0])[t - 1] if t > 0 else 0
            total_capital = green_capital + brown_capital

            # Calcul de l'intensit√© √©nerg√©tique micro√©conomique
            energy_intensity = compute_firm_energy_intensity(firm, t, params["epsilon_V"], params["epsilon_B"])
    
            # Production ou consommation adress√©e √† la firme
            production = firm.get("Production", [0]*num_periods)[t]
    
            # Calcul des besoins √©nerg√©tiques (√† utiliser ensuite dans update_biophys_vars)
            firm["EnergyNeeded"] = energy_intensity * production


    # Productivit√© endog√®ne croissante avec le capital vert
            base_productivity = 30
            gamma = 20
            productivity = base_productivity + gamma * (green_capital / (green_capital + brown_capital + 1e-6))

    # Production maximale avec bruit al√©atoire (efficacit√© variable)
            shock = random.uniform(0.85, 1.15)
            production = total_capital * productivity * shock

    # M√©moriser cette production
            if "Production" not in firm:
                firm["Production"] = [0] * num_periods
            firm["Production"][t] = production

    # --- 2. Recalcul de la demande d'emplois ---
            green_ratio = firm.get("GreenCapitalRatio", [0])[t - 1] if t > 0 else 0.5
            brown_ratio = 1 - green_ratio

            base_productivity_demand = 60
        
            green_jobs_total = (production / base_productivity_demand) / green_ratio if green_ratio > 0 else 0
            brown_jobs_total = (production / base_productivity_demand) / brown_ratio if brown_ratio > 0 else 0

    # Fluctuation r√©aliste de l'organisation du travail
            green_high = int(green_jobs_total * random.uniform(0.4, 0.6))
            green_low = int(green_jobs_total - green_high)
            brown_high = int(brown_jobs_total * random.uniform(0.4, 0.6))
            brown_low = int(brown_jobs_total - brown_high)

            firm_id = firm["FirmID"]

            current_green_high = sum(1 for h in household_list if h["IdEmployer"] == firm_id and h["Status"] == 5)
            current_green_low = sum(1 for h in household_list if h["IdEmployer"] == firm_id and h["Status"] == 2)
            current_brown_high = sum(1 for h in household_list if h["IdEmployer"] == firm_id and h["Status"] == 4)
            current_brown_low = sum(1 for h in household_list if h["IdEmployer"] == firm_id and h["Status"] == 1)

            firm["GreenHighSkilledDemand"] = green_high - current_green_high
            firm["GreenLowSkilledDemand"] = green_low - current_green_low
            firm["BrownHighSkilledDemand"] = brown_high - current_brown_high
            firm["BrownLowSkilledDemand"] = brown_low - current_brown_low

# === BOUCLE DE MISE √Ä JOUR DU STATUT D'EMPLOI SELON DEMANDE NETTE ===
        # === BOUCLE DE MISE √Ä JOUR DU STATUT D'EMPLOI SELON DEMANDE NETTE ===

# === BOUCLE DE MISE √Ä JOUR DU STATUT D'EMPLOI SELON DEMANDE NETTE (avec distinction ch√¥mage vs emploi garanti) ===

        for h, household in enumerate(household_list):
            status = household["Status"]
            skill = household["SkillStatus"]
            employer_id = household["IdEmployer"]
            reskilling_counter = household.get("ReskillingCounter", 0)
           
            brown_retention = 0.8
            green_retention = 0.85
            brown_qualified_retention = 0.9
            green_qualified_retention = 0.92

                # --- 1. Formation (Status = 6)
            if status == 6:
                    reskilling_counter += 1
                    if reskilling_counter >= 2:
                            household["Status"] = 0  # retour au ch√¥mage classique
                            household["IdEmployer"] = -1
                            reskilling_counter = 0
                    household["ReskillingCounter"] = reskilling_counter
                    continue

                # --- 2. Emploi garanti si au ch√¥mage et transition active, avec probabilit√©
            if status == 0 and TransitionActive[t] == 1 and random.random() < 0.3:
                    household["Status"] = 3  # emploi garanti
                    household["IdEmployer"] = -1
                    household["Income"].append(minimum_wage[t])
                    continue

                # --- 3. Licenciements al√©atoires (5% turnover) ou par demande nette
            if status in [1, 2, 4, 5] and employer_id != -1:
                    firm = firm_list[employer_id]
                    fired = False

                    if random.random() < 0.05:
                            fired = True
                    elif status == 1 and firm["BrownLowSkilledDemand"] < 0 and random.random() > 0.8:
                            firm["BrownLowSkilledDemand"] += 1
                            fired = True
                    elif status == 2 and firm["GreenLowSkilledDemand"] < 0 and random.random() > 0.85:
                            firm["GreenLowSkilledDemand"] += 1
                            fired = True
                    elif status == 4 and firm["BrownHighSkilledDemand"] < 0 and random.random() > 0.9:
                            firm["BrownHighSkilledDemand"] += 1
                            fired = True
                    elif status == 5 and firm["GreenHighSkilledDemand"] < 0 and random.random() > 0.92:
                            firm["GreenHighSkilledDemand"] += 1
                            fired = True

                    if fired:
                            household["Status"] = 0  # retour au ch√¥mage
                            household["IdEmployer"] = -1
                            continue

                # --- 4. Embauche si au ch√¥mage (Status = 0) et demande positive
            if household["Status"] == 0:
                    random.shuffle(firm_list)
                    for firm in firm_list:
                            fid = firm["FirmID"]

                            if skill == 0:
                                    if firm["BrownLowSkilledDemand"] > 0:
                                            household["Status"] = 1
                                            household["IdEmployer"] = fid
                                            firm["BrownLowSkilledDemand"] -= 1
                                            break
                                    elif firm["GreenLowSkilledDemand"] > 0:
                                            household["Status"] = 2
                                            household["IdEmployer"] = fid
                                            firm["GreenLowSkilledDemand"] -= 1
                                            break

                            elif skill == 1:
                                    if firm["BrownHighSkilledDemand"] > 0:
                                            household["Status"] = 4
                                            household["IdEmployer"] = fid
                                            firm["BrownHighSkilledDemand"] -= 1
                                            break
                                    elif firm["GreenHighSkilledDemand"] > 0:
                                            household["Status"] = 5
                                            household["IdEmployer"] = fid
                                            firm["GreenHighSkilledDemand"] -= 1
                                            break
 


        # --- BOUCLE BANQUES ---
        for bank in bank_list:
            bank["TargetLeverage"].append(random.uniform(0.01, 0.1))
            bank["BanksAnimalSpirits"].append(random.uniform(0.5, 1.5))
            bank["RiskAppetite"].append(random.uniform(0.01, 0.9))
            bank["MarketShareBank"].append(random.uniform(0.05, 0.1))

        # --- BOUCLE FIRMES ---
        for firm in firm_list:
            # Initialisation des constantes ou param√®tres dynamiques
            for key, value in {
                "LoanInterestRate": random.uniform(0.01, 0.05),
                "GreenLoanInterestRate": random.uniform(0.01, 0.05),
                "AnimalSpirits_B": random.uniform(0, 0.02),
                "AnimalSpirits_V": random.uniform(0, 0.02),
                "gamma1": 0.01,
                "gamma2": 0.01,
                "gamma3": 0.01,
                "gamma4": 0.01
            }.items():
                if key not in firm:
                    firm[key] = []
                firm[key].append(value)

            if t == 0:
                # Initialisation s√©curis√©e des listes pour t = 0
                for key in [
                    "BaseWage", "LowSkilledBrownWage", "LowSkilledGreenWage",
                    "HighSkilledBrownWage", "HighSkilledGreenWage",
                    "BrownInvestment", "GreenInvestment", "BrownInvDes", "GreenInvDes",
                    "BrownLoansDem", "GreenLoansDem", "BrownLoansVar", "GreenLoansVar",
                    "CreditConstraintVar", "CreditConstraintInt",
                    "TotalCapital", "GreenCapitalRatio", "ratiocashflow", "LeverageFirm",
                    "FullCapacityProduction", "Investment", "Loans",
                    "GreenInvestmentShare", "BrownInvestmentShare"
                ]:
                    firm[key] = [0]

                # Assurer que TotalDebt existe √† t = 0
                if "TotalDebt" not in firm:
                    firm["TotalDebt"] = [0]

                # Initialisation des pr√™ts (divis√© en deux)
                firm["BrownLoans"] = [firm["TotalDebt"][0] / 2]
                firm["GreenLoans"] = [firm["TotalDebt"][0] / 2]

                # Initialisation d√©pendant du capital
                total_capital = firm["BrownCapital"][0] + firm["GreenCapital"][0]
                firm["TotalCapital"][0] = total_capital
                firm["GreenCapitalRatio"][0] = (
                    firm["GreenCapital"][0] / total_capital if total_capital > 0 else 0
                )
                firm["FullCapacityProduction"][0] = 0.8 * total_capital
            else:
                base = base_wage * firm.get("ProductivityFactor", 1.0)
                firm["BaseWage"].append(base)
                firm["LowSkilledBrownWage"].append(base)
                firm["LowSkilledGreenWage"].append(base * (1 + green_premium))
                firm["HighSkilledBrownWage"].append(base * (1 + skill_premium))
                firm["HighSkilledGreenWage"].append(base * (1 + green_skill_premium))

                 # Calcul du salaire de base
                base = base_wage * firm.get("ProductivityFactor", 1.0)              

                # Salaires brun et vert peu qualifi√©s
                firm["LowSkilledBrownWage"] = firm.get("LowSkilledBrownWage", []) + [base]
                firm["LowSkilledGreenWage"] = firm.get("LowSkilledGreenWage", []) + [base * (1 + green_premium)]

                # Salaires brun et vert qualifi√©s
                firm["HighSkilledBrownWage"] = firm.get("HighSkilledBrownWage", []) + [base * (1 + skill_premium)]
                firm["HighSkilledGreenWage"] = firm.get("HighSkilledGreenWage", []) + [base * (1 + green_skill_premium)]
            
                # Fallback s√©curis√© si LoanInterestRate ou GreenLoanInterestRate sont absents
                if len(firm["LoanInterestRate"]) <= t - 1:
                    firm["LoanInterestRate"].append(0.02)
                if len(firm["GreenLoanInterestRate"]) <= t - 1:
                    firm["GreenLoanInterestRate"].append(0.015)

                                # Ratios financiers n√©cessaires
                prev_capital = firm["TotalCapital"][t - 1] if len(firm["TotalCapital"]) > t - 1 else 1
                prev_profits = firm["Profits"][0]  # profits constants dans cette version
                prev_debt = firm["TotalDebt"][t - 1] if len(firm["TotalDebt"]) > t - 1 else 100

                firm["ratiocashflow"].append(prev_profits / prev_capital if prev_capital > 0 else 0)
                firm["LeverageFirm"].append(prev_debt / prev_capital if prev_capital > 0 else 0)
                firm["FullCapacityProduction"].append(0.8 * prev_capital)

                # --- Croissance d√©sir√©e des capitaux
                growth_b = max(0, firm["AnimalSpirits_B"][t]
                               + firm["gamma1"][t] * firm["ratiocashflow"][t]
                               - firm["gamma2"][t] * firm["LeverageFirm"][t]
                               + firm["gamma3"][t] * 0.7
                               - firm["gamma4"][t] * firm["LoanInterestRate"][t - 1])
 
                growth_v_firm = max(0, firm["AnimalSpirits_V"][t]
                                   + firm["gamma1"][t] * firm["ratiocashflow"][t]
                                   - firm["gamma2"][t] * firm["LeverageFirm"][t]
                                   + firm["gamma3"][t] * 0.7
                                   - firm["gamma4"][t] * firm["GreenLoanInterestRate"][t - 1])

                firm["GrKdB"].append(growth_b)
                firm["GrKdV"].append(growth_v_firm)

# --- Investissement d√©sir√© brut
                firm["BrownInvDes"].append(growth_b * firm["BrownCapital"][t - 1])

# Taxe carbone si activ√©e
                if carbon_tax_active:
                    carbon_tax_rate = 0.05
                    carbon_cost = carbon_tax_rate * firm["BrownCapital"][t - 1]
                    firm["BrownInvDes"][t] = firm["BrownInvDes"][t] - carbon_cost

# Politique verte
                if CarbonTaxActive[t] == 1:
                    growth_v.append(0.01)
                elif TransitionActive[t] == 1:
                    growth_v.append(0.02)
                elif PostGrowthActive[t] == 1:
                    growth_v.append(0.005)
                else:
                    growth_v.append(growth_v[t - 1])

                firm["GreenInvDes"].append(growth_v[t] * firm["GreenCapital"][t - 1])

# --- Demandes de pr√™ts
                firm["BrownLoansDem"].append(firm["BrownInvDes"][t])
                firm["GreenLoansDem"].append(firm["GreenInvDes"][t])

# --- Pr√™ts accord√©s sous contraintes
                bank = bank_list[firm["IdBank"]]
                target_leverage = bank["TargetLeverage"][t]
                bank_spirits = bank["BanksAnimalSpirits"][t]

                ccv = bank_spirits * (firm["LeverageFirm"][t - 1] - target_leverage)
                cci = bank_spirits * (firm["LeverageFirm"][t - 1] - target_leverage)

                firm["CreditConstraintVar"].append(min(1, max(0, ccv)))
                firm["CreditConstraintInt"].append(min(1, max(0, cci)))

                cb_rate = central_bank_rate[t]
                market_share = bank["MarketShareBank"][t]
                markup = 0.02 * market_share

                firm["LoanInterestRate"][t] = cb_rate + markup + firm["CreditConstraintInt"][t] * 0.02
                firm["GreenLoanInterestRate"][t] = firm["LoanInterestRate"][t] - 0.01

                brown_cap = brown_loan_cap[t]
                allowed_brown = brown_cap * firm["BrownLoansDem"][t]

                brown_loans_unconstrained = min(firm["BrownLoansDem"][t], firm["CreditConstraintVar"][t], allowed_brown)
                if scenario == "post_growth":
                    brown_loans_final = brown_loans_unconstrained * max_brown_credit
                else:
                    brown_loans_final = brown_loans_unconstrained

                firm["BrownLoansVar"].append(brown_loans_final)
                firm["BrownInvestment"].append(brown_loans_final)

                green_loans_final = firm["GreenInvDes"][t] * (1 - firm["CreditConstraintVar"][t])
                firm["GreenLoansVar"].append(green_loans_final)
                firm["GreenInvestment"].append(green_loans_final)

                previous_brown_cap = firm["BrownCapital"][t - 1]
                brown_investment = firm["BrownInvestment"][t]

                # Test de validation (facultatif)
#                if sim == 0 and t in [1, 5, 10, 15, 20]:
#                    print(f"[t={t}] Firm {firm['FirmID']} | BrownInvDes={firm['BrownInvDes'][t]:.2f} | BrownInvestment={brown_loans_final:.2f}")
                if PostGrowthActive[t] == 1:
                    updated_brown_cap = max(0, previous_brown_cap * 0.80 + brown_investment)
                else:
                    updated_brown_cap = previous_brown_cap + brown_investment

                firm["BrownCapital"].append(updated_brown_cap)
                firm["GreenCapital"].append(firm["GreenCapital"][t - 1] + firm["GreenInvestment"][t])
                firm["BrownLoans"].append(firm["BrownLoans"][t - 1] + firm["BrownLoansVar"][t])
                firm["GreenLoans"].append(firm["GreenLoans"][t - 1] + firm["GreenLoansVar"][t])
                total_capital = firm["BrownCapital"][t] + firm["GreenCapital"][t]
                firm["TotalCapital"].append(total_capital)
                firm["TotalDebt"].append(firm["BrownLoans"][t] + firm["GreenLoans"][t])
                firm["GreenCapitalRatio"].append(firm["GreenCapital"][t] / total_capital if total_capital > 0 else 0)

           # √Ä LA FIN DE CHAQUE FIRM, on peut calculer :
            bank = bank_list[firm["IdBank"]]
#            if t < len(firm["BrownCapital"]):
            all_results.append({
                "Simulation": sim,
                "Period": t,
                "FirmID": firm["FirmID"],
                "BrownCapital": firm["BrownCapital"][t],
                "GreenCapital": firm["GreenCapital"][t],
                "CreditConstraintVar": firm["CreditConstraintVar"][t],
                "TotalCapital": firm["TotalCapital"][t],
                "GreenCapitalRatio": firm["GreenCapitalRatio"][t],
                "Failures": bank["Failures"][0],
                "RiskAppetite": bank["RiskAppetite"][t],
                "TargetLeverage": bank["TargetLeverage"][t],
                "BanksAnimalSpirits": bank["BanksAnimalSpirits"][t],
                "ScenarioName": scenario_name,
                "Revenue": firm["Revenue"][t] if "Revenue" in firm and len(firm["Revenue"]) > t else 0.0,

            })


        # Moyenne du revenu disponible pour les m√©nages √† t-1
        if t > 0:
            total_disp = sum(h["DisposableIncome"][t - 1] for h in household_list)
            mean_disp_income = total_disp / len(household_list)
        else:
            mean_disp_income = 1.0  # √©viter division par z√©ro


        for household in household_list:
            if t == 0:
                household["DisposableIncome"].append(0)
                household["FinancialIncome"].append(0)
                household["TaxesInd"].append(0)
                household["HouseholdDebtService"].append(0)
                household["HouseholdNewDebt"].append(0)
                household["BaseConsumption"].append(0)
                household["Consumption"].append(0)
                household["Savings"].append(household["Savings"][0])
                household["BaseConsumption"] = []
                household["SuppCons"] = []
                household["ConsAg"] = []
                household["ConsEner"] = []
                household["ConsHous"] = []
                household["ConsTrans"] = []
                household["SuppConsAg"] = []
                household["SuppConsEner"] = []
                household["SuppConsHous"] = []
                household["SuppConsTrans"] = []
                household["SuppConsInd"] = []
                household["SuppConsTC"] = []
                continue

            status = household["Status"]
            employer_id = household["IdEmployer"]
            savings_lag = household["Savings"][t - 1]
            debt_lag = household["HouseholdTotalDebt"][t - 1]
            income_lag = household["Income"][t - 1]

            if status in [0, 4]:
                income = unemployment_benefit[t]
            elif status == 3:
                income = minimum_wage[t]
            else:
                firm = next((f for f in firm_list if f["FirmID"] == employer_id), None)
                if firm is not None:
                    if status == 1:
                        income = firm["LowSkilledBrownWage"][t]
                    elif status == 2:
                        income = firm["LowSkilledGreenWage"][t]
                    elif status == 5:
                        income = firm["HighSkilledBrownWage"][t]
                    elif status == 6:
                        income = firm["HighSkilledGreenWage"][t]
                    else:
                        income = 0
                else:
                    income = 0

            household["Income"].append(income)

            deposit_rate = household["DepositInterestRate"][0]
            financial_income = deposit_rate * savings_lag
            household["FinancialIncome"].append(financial_income)

            taxes = household["TaxRate"][0] * income_lag
            household["TaxesInd"].append(taxes)

            loan_rate = household["LoanRateCons"][0]
            debt_service = loan_rate * debt_lag
            household["HouseholdDebtService"].append(debt_service)

            red = household["Red"][0]
            disp_income = (income + financial_income + red) - (taxes + debt_service)
            household["DisposableIncome"].append(disp_income)

            # --- IMPACT DE LA TAXE CARBONE SUR LE REVENU DISPONIBLE DES M√âNAGES ---
            if carbon_tax_active:
                carbon_tax_rate = 0.1  # Exemple : 5% de taxe
                carbon_cost_household = carbon_tax_rate * household["DisposableIncome"][t]
                household["DisposableIncome"][t] = max(0, household["DisposableIncome"][t] - carbon_cost_household)

            # Param√®tres de la politique sociale post growth
            RBU_amount = 4  # Revenu de base universel fixe par m√©nage et p√©riode
            income_tax_threshold = 30  # Seuil de revenu √† partir duquel la taxe s'applique
            progressive_tax_rate = 0.25  # Taux d'imposition sur la part de revenu > threshold

            if scenario_name == "post_growth":
                income_t = household["Income"][t]

                # Calcul de la taxe progressive simul√©e sur hauts revenus
                taxable_income = max(0, income_t - income_tax_threshold)
                tax_amount = progressive_tax_rate * taxable_income

                # Revenu disponible avant redistribution
                dispo_before = household["DisposableIncome"][t]

                # On retire la taxe
                dispo_after_tax = max(0, dispo_before - tax_amount)

                # Ajout du revenu de base universel
                dispo_final = dispo_after_tax + RBU_amount

                household["DisposableIncome"][t] = dispo_final

            # Calcul du coefficient de Gini sur le revenu disponible des m√©nages √† la p√©riode t
            disposable_incomes_t = [h["DisposableIncome"][t] for h in household_list]
            gini_t = gini_coefficient(disposable_incomes_t)

            # Stockage de l‚Äôindicateur pour analyses ult√©rieures
            gini_records.append({
                "Simulation": sim,
                "Period": t,
                "GiniDisposableIncome": gini_t,
                "ScenarioName": scenario_name
            })


            base_c = 10 
            household["BaseConsumption"].append(base_c)

            ptc_di = household["PropensityToConsumeDI"][0]
            ptc_s = household["PropensityToConsumeSavings"][0]
            available = disp_income + savings_lag

            if available >= base_c:
                additional = base_c + ptc_di * (disp_income - base_c) + ptc_s * savings_lag
                consumption = min(additional, available)
                household["HouseholdNewDebt"].append(0)
            else:
                consumption = base_c
                debt_needed = base_c - available
                household["HouseholdNewDebt"].append(debt_needed)

            household["Consumption"].append(consumption)

            new_debt = household["HouseholdNewDebt"][t]
            total_debt = debt_lag + new_debt
            household["HouseholdTotalDebt"].append(total_debt)

            saving = savings_lag + (disp_income - consumption + new_debt)
            household["Savings"].append(max(0, saving))

            # Calcul du GrNeedsIndex et mise √† jour du NeedsIndex
            hum0 = 0.01
            hum1 = 0.01

            disp_income_lag = household["DisposableIncome"][t - 1] if t > 0 else 1.0
            base_c_lag = household["BaseConsumption"][t - 1] if t > 0 else 1.0
            needs_index_lag = household["NeedsIndex"][t - 1] if t > 0 else 100.0

            term1 = hum0 * (1 - base_c_lag / disp_income_lag) if disp_income_lag > 0 else 0
            term2 = hum1 * (disp_income_lag / mean_disp_income) if mean_disp_income > 0 else 0

            gr_needs_index = term1 + term2
            household["GrNeedsIndex"].append(gr_needs_index)

            new_needs_index = max(0, needs_index_lag * (1 + gr_needs_index))
            household["NeedsIndex"].append(new_needs_index)

        # -- Prix sectoriels (utilisent l'inflation)
        price_ag = price_ag_list[t - 1] * (1 + general_inflation[t]) if t > 0 else 1.0
        price_ener = price_ener_list[t - 1] * (1 + general_inflation[t]) if t > 0 else 1.0
        price_hous = price_hous_list[t - 1] * (1 + general_inflation[t]) if t > 0 else 1.0
        price_trans = price_trans_list[t - 1] * (1 + general_inflation[t]) if t > 0 else 1.0

        price_ag_list.append(price_ag)
        price_ener_list.append(price_ener)
        price_hous_list.append(price_hous)
        price_trans_list.append(price_trans)

        # -- Boucle sur chaque m√©nage
        for household in household_list:
            if t == 0:
                
                # Initialisation √† t=0
                household["ConsAg"].append(1.0)
                household["ConsEner"].append(1.0)
                household["ConsHous"].append(1.0)
                household["ConsTrans"].append(1.0)
                household["BaseConsumption"].append(4.0)
                household["SuppCons"].append(0.0)
                for key in ["SuppConsAg", "SuppConsEner", "SuppConsHous", "SuppConsTrans", "SuppConsInd", "SuppConsTC"]:
                    household[key].append(0.0)
                continue

          # --- Base consumption per category
            cons_ag = household["ConsAg"][t - 1] * (1 + (price_ag - price_ag_list[t - 1]))
            cons_ener = household["ConsEner"][t - 1] * (1 + (price_ener - price_ener_list[t - 1]))
            cons_hous = household["ConsHous"][t - 1] * (1 + (price_hous - price_hous_list[t - 1]))
            cons_trans = household["ConsTrans"][t - 1] * (1 + (price_trans - price_trans_list[t - 1]))

            household["ConsAg"].append(cons_ag)
            household["ConsEner"].append(cons_ener)
            household["ConsHous"].append(cons_hous)
            household["ConsTrans"].append(cons_trans)

            base_c = cons_ag + cons_ener + cons_hous + cons_trans
            household["BaseConsumption"].append(base_c)

            total_cons = household["Consumption"][t]
            supp_cons = total_cons - base_c
            household["SuppCons"].append(supp_cons)

            # --- Supp consumption by category
            household["SuppConsAg"].append(household["AgPref"] * supp_cons)
            household["SuppConsEner"].append(household["EnerPref"] * supp_cons)
            household["SuppConsHous"].append(household["HousPref"] * supp_cons)
            household["SuppConsTrans"].append(household["TransPref"] * supp_cons)
            household["SuppConsInd"].append(household["IndPref"] * supp_cons)
            household["SuppConsTC"].append(household["TCPref"] * supp_cons)


            total_base = sum(h["BaseConsumption"][t] for h in household_list)
            total_supp = sum(h["SuppCons"][t] for h in household_list)
            total_conso = total_base + total_supp
            total_revenue = sum(
                f["Revenue"][t] if "Revenue" in f and len(f["Revenue"]) > t else 0.0
                for f in firm_list
            )
#            print(f"[t={t}] Conso totale: {total_conso:.2f} | Revenus firmes: {total_revenue:.2f}")


            # Mise √† jour fictive du vote pour permettre le calcul de l‚Äôeffet bandwagon
            # (√Ä remplacer plus tard par une vraie r√®gle comportementale)
            prev_vote = household["VoteDecision"][-1]

            
            # --- D√âCISION DE VOTE ---

            needs_index = household["NeedsIndex"][t]
            needs_index_prev = household["NeedsIndex"][t - 1]
            vote_prev = household["VoteDecision"][t - 1]
            bandwagon_prev = bandwagon_effect[t - 1]

            # Pond√©rations
            w_needs = 0.4
            w_bandwagon = 0.4
            w_inertia = 0.4

            # Calcul de la probabilit√© de voter pro-transition
            vote_prob = (
                w_needs * (needs_index - needs_index_prev) +
                w_bandwagon * bandwagon_prev +
                w_inertia * vote_prev
            )

            # Clamping entre 0 et 1
            vote_prob = max(0, min(1, vote_prob))

            # D√©cision finale
            new_vote = 1 if random.random() < vote_prob else 0
            household["VoteDecision"].append(new_vote)

#        if t in [5, 10, 15, 20, 24]:
 #           print(f"SIM {sim} | T = {t} | SC√âNARIO = {scenario_name}")
  #          print(f"‚Üí Vote pro-transition : {sum(1 for h in household_list if h['VoteDecision'][t] == 1)}")
   #         print(f"‚Üí TransitionActive[t] = {TransitionActive[t]}")
    #        print(f"‚Üí CarbonTaxActive[t] = {CarbonTaxActive[t]}")
     #       print(f"‚Üí PostGrowthActive[t] = {PostGrowthActive[t]}")



        for h_id, h in enumerate(household_list):
            needsindex_records.append({
                "Simulation": sim,
                "HouseholdID": h_id,
                "Period": t,
                "NeedsIndex": h["NeedsIndex"][t],
                "ScenarioName": scenario_name
            })


        involuntary_unemployed = sum(1 for h in household_list if h["Status"] == 3 and h["IdEmployer"] == -1)
        unemployment_rate = involuntary_unemployed / num_households

        social_cost_records.append({
        "Simulation": sim,
        "Period": t,
        "UnemploymentRate": unemployment_rate,
        "ScenarioName": scenario_name
        })

        status_counts = {s: 0 for s in range(8)}
        for h in household_list:
                    # S√©curisation explicite
            for key in ["SuppCons", "BaseConsumption", "Consumption"]:
                if len(household[key]) <= t:
                    household[key].append(0.0)
            for key in ["SuppConsAg", "SuppConsEner", "SuppConsHous", "SuppConsTrans", "SuppConsInd", "SuppConsTC"]:
                if len(household[key]) <= t:
                    household[key].append(0.0)


            s = h["Status"]
            status_counts[s] += 1

        for s in range(8):
            status_share_records.append({
                "Simulation": sim,
                "Period": t,
                "Status": s,
                "Share": status_counts[s] / num_households,
                "ScenarioName": scenario_name
            })

        if t in [5, 10, 15, 20, 24]:
            if scenario_name == "carbon_tax_only":
                policy_active = CarbonTaxActive[t] if len(CarbonTaxActive) > t else 0
            elif scenario_name == "transition_mix":
                policy_active = TransitionActive[t] if len(TransitionActive) > t else 0
            elif scenario_name == "post_growth":
                policy_active = PostGrowthActive[t] if len(PostGrowthActive) > t else 0
            else:
                policy_active = 0  # fallback de s√©curit√©

            policy_outcomes.append({
                "Simulation": sim,
                "ScenarioName": scenario_name,
                "Period": t,
                "EcologicalPolicyActive": policy_active
            })

    # --- CALCUL DU PIB ---

    # 1. Consommation totale
        total_consumption = sum(h["Consumption"][t] for h in household_list)

    # 2. Investissement total (brown + green) des firmes
        total_investment = sum(f["BrownInvestment"][t] + f["GreenInvestment"][t] for f in firm_list)

        # 3. D√©penses publiques :
        # - investissement public vert (part de GreenInvestment non priv√©e)
        public_green_investment = 0.0
        if t > 0 and TransitionActive[t - 1] == 1:
            for f in firm_list:
                green_capital_last = f["GreenCapital"][t - 1]
                public_green_investment += 0.05 * green_capital_last  # taux cod√© en dur

        # - allocations ch√¥mage (Status = 0, 3, 4)
        public_unemployment_benefits = sum(unemployment_benefit[t] for h in household_list if h["Status"] in [0, 4])

        # - emploi garanti (Status = 3 sans employeur)
        public_guaranteed_jobs = sum(minimum_wage[t] for h in household_list if h["Status"] == 3 and h["IdEmployer"] == -1)

#        compute_firm_revenues_and_profits(t, firm_list, household_list, CarbonTaxActive)

 #       total_revenue = sum(
  #          f["Revenue"][t] if "Revenue" in f and len(f["Revenue"]) > t else 0.0
   #         for f in firm_list
     #   )
    #    print(f"[t={t}] Revenus totaux des firmes : {total_revenue:.2f}")

        # D√©pense publique totale
        total_public_spending = public_green_investment + public_unemployment_benefits + public_guaranteed_jobs

        # 4. Agr√©gation
        gdp_value = total_consumption + total_investment
    # total_public_spending

        gdp_records.append({
            "Simulation": sim,
            "Period": t,
            "GDP": gdp_value,
            "ScenarioName": scenario_name
        })

        update_biophys_vars(nature, firm_list, t, params)

# --- MISE √Ä JOUR DE TransitionActive, CarbonTaxActive, PostGrowthActive ---
        if t == 0:
            TransitionActive.append(0)
            CarbonTaxActive.append(0)
            PostGrowthActive.append(0)

        elif t in [5, 10, 15, 20]:  # p√©riodes d‚Äô√©lection
            nb_pro = sum(1 for h in household_list if h["VoteDecision"][t] == 1)
            majority_threshold = num_households // 2

            if nb_pro > majority_threshold:
                # √Ä partir de la p√©riode suivante, activer la transition pour ce sc√©nario
                for future_t in range(t + 1, min(t + 6, num_periods)):
                    TransitionActive[future_t] = 1
                    if scenario_name == "carbon_tax_only":
                        CarbonTaxActive[future_t] = 1
                        PostGrowthActive[future_t] = 0
                    elif scenario_name == "transition_mix":
                        CarbonTaxActive[future_t] = 1
                        PostGrowthActive[future_t] = 0
                    elif scenario_name == "post_growth":
                        CarbonTaxActive[future_t] = 1
                        PostGrowthActive[future_t] = 1
            else:
                # Sinon, aucune politique √©cologique
                for future_t in range(t + 1, min(t + 6, num_periods)):
                    TransitionActive[future_t] = 0
                    CarbonTaxActive[future_t] = 0
                    PostGrowthActive[future_t] = 0
        else:
            # On prolonge les d√©cisions pr√©c√©dentes si pas de vote
            TransitionActive.append(TransitionActive[t - 1])
            CarbonTaxActive.append(CarbonTaxActive[t - 1])
            PostGrowthActive.append(PostGrowthActive[t - 1])

        ecological_policy_active = 0

        if scenario_name == "carbon_tax_only":
            ecological_policy_active = int(CarbonTaxActive[t] == 1)
        elif scenario_name == "transition_mix":
            ecological_policy_active = int(TransitionActive[t] == 1)
        elif scenario_name == "post_growth":
            ecological_policy_active = int(PostGrowthActive[t] == 1)

        policy_records.append({
            "Simulation": sim,
            "ScenarioName": scenario_name,
            "Period": t,
            "EcologicalPolicyActive": ecological_policy_active
        })

        current_scenario = scenario_name

# Cr√©ation d'un DataFrame pour VoteDecision
        for h_id, h in enumerate(household_list):
            for t in range(1, num_periods):
                if t < len(h["VoteDecision"]):
                    vote_records.append({
                        "HouseholdID": h_id,
                        "Period": t,
                        "VoteDecision": h["VoteDecision"][t],
                        "ScenarioName": scenario_name,  # ajout
                        "Simulation": sim
                    })


for h_id, h in enumerate(household_list):
    for t in range(1, num_periods):
        household_records.append({
            "HouseholdID": h_id,
            "IdEmployer": h["IdEmployer"],
            "Period": t,
            "Income": h["Income"][t],
            "DisposableIncome": h["DisposableIncome"][t],
            "BaseConsumption": h["BaseConsumption"][t],
            "Consumption": h["Consumption"][t],
            "Savings": h["Savings"][t],
            "Debt": h["HouseholdTotalDebt"][t],
            "VoteDecision": h["VoteDecision"][t],
            "ScenarioName": current_scenario,  #  Ajout
            "Simulation": sim                  #  Ajout
        })



household_df = pd.DataFrame(household_records)

gdp_df = pd.DataFrame(gdp_records)

results_df = pd.DataFrame(all_results)

social_cost_df = pd.DataFrame(social_cost_records)

status_df = pd.DataFrame(status_share_records)

# === Visualisation du NeedsIndex par sc√©nario ===

needsindex_df = pd.DataFrame(needsindex_records)

policy_df = pd.DataFrame(policy_outcomes)

vote_df = pd.DataFrame(vote_records)

gini_df = pd.DataFrame(gini_records)

plot_climate_variables(nature, num_periods, scenario_name)

plt.figure(figsize=(10, 6))
sns.lineplot(data=gini_df, x="Period", y="GiniDisposableIncome", hue="ScenarioName", estimator="mean", ci="sd")
plt.title("√âvolution moyenne du coefficient de Gini du revenu disponible par sc√©nario")
plt.xlabel("P√©riode")
plt.ylabel("Coefficient de Gini")
plt.grid(True)
plt.tight_layout()
plt.show()

max_period = household_df["Period"].max()
subset = household_df[household_df["Period"] <= max_period]


# Calcul de la proportion moyenne et √©cart-type des votes pro-transition par sc√©nario et p√©riode
vote_share_by_sim = (
    vote_df.groupby(["ScenarioName", "Simulation", "Period"])["VoteDecision"]
    .mean()
    .reset_index()
)

vote_summary = (
    vote_share_by_sim
    .groupby(["ScenarioName", "Period"])["VoteDecision"]
    .agg(MeanVoteShare="mean", StdDevVoteShare="std")
    .reset_index()
)

# Trac√©
plt.figure(figsize=(12, 7))
for scenario in vote_summary["ScenarioName"].unique():
    data = vote_summary[vote_summary["ScenarioName"] == scenario]
    plt.plot(data["Period"], data["MeanVoteShare"], label=scenario.capitalize().replace("_", " "))
    plt.fill_between(
        data["Period"],
        data["MeanVoteShare"] - data["StdDevVoteShare"],
        data["MeanVoteShare"] + data["StdDevVoteShare"],
        alpha=0.2
    )

plt.title("Soutien politique aux trajectoires de transition selon les sc√©narios")
plt.xlabel("P√©riode")
plt.ylabel("Proportion moyenne de votes pro-transition (VoteDecision=1)")
plt.ylim(0, 1)
plt.legend(title="Sc√©narios")
plt.grid(True)
plt.tight_layout()
plt.show()


# Agr√©gation par p√©riode
revenue_agg = results_df.groupby("Period")["Revenue"].sum().reset_index(name="RevenusFirme")
consumption_agg = household_df.groupby("Period")["Consumption"].sum().reset_index(name="ConsommationMenages")

# Fusion des deux
merged_df = pd.merge(revenue_agg, consumption_agg, on="Period")

# Trac√©
plt.figure(figsize=(10, 6))
plt.plot(merged_df["Period"], merged_df["ConsommationMenages"], label="Consommation totale des m√©nages", linewidth=2)
plt.plot(merged_df["Period"], merged_df["RevenusFirme"], label="Revenus totaux des firmes", linewidth=2, linestyle='--')
plt.xlabel("P√©riode")
plt.ylabel("Montants")
plt.title("Consommation des m√©nages vs Revenus des firmes")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Trac√©
plt.figure(figsize=(14, 8))
sns.lineplot(
    data=subset,
    x="Period",
    y="IdEmployer",
    hue="HouseholdID",
    palette="husl",
    linewidth=0.8,
    legend=False,
    alpha=0.6
)

plt.title("√âvolution de l'IdEmployer des m√©nages au cours du temps")
plt.xlabel("P√©riode")
plt.ylabel("IdEmployer (-1 = sans emploi)")
plt.grid(True)
plt.tight_layout()
plt.show()

# On suppose que vote_df est d√©j√† bien format√©
# Groupement par sc√©nario, p√©riode et simulation pour calculer les parts
vote_agg = (
    vote_df.groupby(["ScenarioName", "Simulation", "Period"])["VoteDecision"]
    .mean()
    .reset_index()
)

# Agr√©gation finale : moyenne et √©cart-type par sc√©nario et p√©riode
vote_summary = (
    vote_agg.groupby(["ScenarioName", "Period"])["VoteDecision"]
    .agg(Mean="mean", Std="std")
    .reset_index()
)

# Graphique
plt.figure(figsize=(12, 6))
for scenario in vote_summary["ScenarioName"].unique():
    data = vote_summary[vote_summary["ScenarioName"] == scenario]
    plt.plot(data["Period"], data["Mean"], label=scenario)
    plt.fill_between(
        data["Period"],
        data["Mean"] - data["Std"],
        data["Mean"] + data["Std"],
        alpha=0.2
    )

plt.title("Proportion de VoteDecision = 1 par p√©riode (avec √©cart-type)")
plt.xlabel("P√©riode")
plt.ylabel("Proportion pro-transition")
plt.ylim(0, 1)
plt.legend(title="Sc√©nario")
plt.grid(True)
plt.tight_layout()
plt.show()


# Si ce n'est pas d√©j√† fait
# vote_df = pd.DataFrame(vote_records)

# Ajout du sc√©nario si absent (si vote_df ne contient que HouseholdID, Period, VoteDecision)
if "ScenarioName" not in vote_df.columns:
    household_scenario_map = household_df[["HouseholdID", "ScenarioName"]].drop_duplicates()
    vote_df = vote_df.merge(household_scenario_map, on="HouseholdID")

# Ajout de l'information de simulation si absente (utile si vote_df n'a pas "Simulation")
if "Simulation" not in vote_df.columns:
    household_simulation_map = household_df[["HouseholdID", "Simulation"]].drop_duplicates()
    vote_df = vote_df.merge(household_simulation_map, on="HouseholdID")

# Calcul des parts pro-transition par sc√©nario, simulation, p√©riode
vote_share_by_sim = (
    vote_df.groupby(["ScenarioName", "Simulation", "Period"])["VoteDecision"]
    .mean()
    .reset_index()
)

# Moyenne et √©cart-type par sc√©nario et p√©riode
vote_summary = (
    vote_share_by_sim
    .groupby(["ScenarioName", "Period"])["VoteDecision"]
    .agg(MeanVoteShare="mean", StdDevVoteShare="std")
    .reset_index()
)

results_df["GreenCapitalShare"] = results_df["GreenCapital"] / results_df["TotalCapital"]

# 3. Part du capital vert
plt.figure(figsize=(10, 6))
sns.lineplot(data=results_df, x="Period", y="GreenCapitalShare", hue="ScenarioName", estimator="mean", ci="sd")
plt.title("Part du capital vert dans le capital total")
plt.tight_layout()
plt.show()

# Trac√©
plt.figure(figsize=(12, 6))
for scenario in vote_summary["ScenarioName"].unique():
    data = vote_summary[vote_summary["ScenarioName"] == scenario]
    plt.plot(data["Period"], data["MeanVoteShare"], label=scenario)
    plt.fill_between(
        data["Period"],
        data["MeanVoteShare"] - data["StdDevVoteShare"],
        data["MeanVoteShare"] + data["StdDevVoteShare"],
        alpha=0.2
    )

plt.title("Proportion moyenne de votes pro-transition par p√©riode et sc√©nario")
plt.xlabel("P√©riode")
plt.ylabel("Part moyenne de VoteDecision = 1")
plt.ylim(0, 1)
plt.legend(title="Sc√©nario")
plt.grid(True)
plt.tight_layout()
plt.show()


# √âvolution agr√©g√©e des votes pro-transition
plt.figure(figsize=(10, 5))
vote_share = vote_df.groupby("Period")["VoteDecision"].mean()
plt.plot(vote_share.index, vote_share.values, marker="o")
plt.title("Part des votes pro-transition (VoteDecision = 1) dans la population")
plt.xlabel("P√©riode")
plt.ylabel("Part de votes pro-transition")
plt.grid(True)
plt.tight_layout()
plt.show()

policy_count_df = (
    policy_df.groupby(["ScenarioName", "Period"])["EcologicalPolicyActive"]
    .sum()
    .reset_index()
)

# 2. Ajouter le sc√©nario associ√© √† chaque m√©nage
household_scenario_map = household_df[["HouseholdID", "ScenarioName"]].drop_duplicates()
needsindex_df_full = needsindex_df.merge(household_scenario_map, on="HouseholdID")

policy_df = pd.DataFrame(policy_records)

policy_count_df = (
    policy_df.groupby(["ScenarioName", "Period"])["EcologicalPolicyActive"]
    .sum()
    .reset_index()
)

plt.figure(figsize=(10, 6))
sns.lineplot(
    data=policy_count_df,
    x="Period",
    y="EcologicalPolicyActive",
    hue="ScenarioName",
    marker="o"
)
plt.title("Nombre de simulations avec politique √©cologique active (par p√©riode et sc√©nario)")
plt.xlabel("P√©riode")
plt.ylabel("Nombre de simulations (sur 10)")
plt.ylim(0, 10)
plt.grid(True, axis="y")
plt.tight_layout()
plt.show()

# Filtrage facultatif pour n'afficher qu'un seul sc√©nario √† la fois
for scenario in policy_df["ScenarioName"].unique():
    scenario_subset = policy_df[policy_df["ScenarioName"] == scenario]

    # Pivot table : lignes = simulations, colonnes = p√©riodes, valeurs = active (0 ou 1)
    heatmap_data = scenario_subset.pivot_table(
        index="Simulation",
        columns="Period",
        values="EcologicalPolicyActive",
        fill_value=0
    )

    plt.figure(figsize=(12, 4))
    sns.heatmap(heatmap_data, cmap="Greens", cbar=True, linewidths=0.2, linecolor="gray", square=False)
    plt.title(f"P√©riodes avec politique √©cologique active ‚Äì sc√©nario : {scenario}")
    plt.xlabel("P√©riode")
    plt.ylabel("Simulation")
    plt.tight_layout()
    plt.show()

# === Visualisation du NeedsIndex par sc√©nario ===

# Assure-toi que needsindex_df est bien cr√©√© avec ScenarioName dans needsindex_records
# (ce bloc suppose que c‚Äôest d√©j√† le cas)

# Agr√©gation par moyenne des parts sur toutes les simulations
status_df_grouped = status_df.groupby(["ScenarioName", "Period", "Status"], as_index=False)["Share"].mean()

plt.figure(figsize=(10, 6))
sns.barplot(
    data=policy_count_df,
    x="Period",
    y="EcologicalPolicyActive",
    hue="ScenarioName"
)
plt.title("Nombre de simulations avec victoire politique √©cologique par sc√©nario")
plt.xlabel("P√©riode √©lectorale")
plt.ylabel("Nombre de simulations (sur 10)")
plt.ylim(0, 10)
plt.grid(True, axis="y")
plt.tight_layout()
plt.show()



# 1. Courbe moyenne du NeedsIndex par sc√©nario avec √©cart-type
plt.figure(figsize=(10, 6))
sns.lineplot(
    data=needsindex_df,
    x="Period",
    y="NeedsIndex",
    hue="ScenarioName",
    estimator="mean",
    ci="sd"
)
plt.title("√âvolution moyenne du NeedsIndex par sc√©nario (avec √©cart-type)")
plt.xlabel("P√©riode")
plt.ylabel("NeedsIndex")
plt.grid(True)
plt.tight_layout()
plt.show()

# 2. Boxplot du NeedsIndex √† diff√©rentes p√©riodes cl√©s
selected_periods = [5, 10, 15, 20, 24]

plt.figure(figsize=(12, 6))
sns.boxplot(
    data=needsindex_df[needsindex_df["Period"].isin(selected_periods)],
    x="Period",
    y="NeedsIndex",
    hue="ScenarioName"
)
plt.title("Distribution du NeedsIndex √† diff√©rentes p√©riodes cl√©s")
plt.xlabel("P√©riode")
plt.ylabel("NeedsIndex")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
sns.lineplot(data=social_cost_df, x="Period", y="UnemploymentRate", hue="ScenarioName", estimator="mean", ci="sd")
plt.title("Ch√¥mage involontaire par sc√©nario (co√ªt social)")
plt.xlabel("P√©riode")
plt.ylabel("Taux de ch√¥mage involontaire")
plt.grid(True)
plt.tight_layout()
plt.show()


# --- Visualisation du PIB par sc√©nario (avec √©cart-type) ---
plt.figure(figsize=(10, 6))
filtered = gdp_df[gdp_df["ScenarioName"].isin(["carbon_tax_only", "transition_mix", "post_growth"])]
sns.lineplot(data=filtered, x="Period", y="GDP", hue="ScenarioName", estimator="mean", ci="sd")
plt.title("PIB moyen par sc√©nario (avec √©cart-type)")
plt.xlabel("P√©riode")
plt.ylabel("PIB agr√©g√©")
plt.grid(True)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
sns.lineplot(data=results_df, x="Period", y="BrownCapital", hue="ScenarioName", estimator="mean", ci="sd")
plt.title("√âvolution du capital brun moyen par sc√©nario")
plt.xlabel("P√©riode")
plt.ylabel("Capital brun moyen")
plt.grid(True)
plt.tight_layout()
plt.show()

# Style
sns.set(style="whitegrid")

# Fin du chronom√®tre
execution_time = time.time() - start_time
print(f"Temps d'ex√©cution du mod√®le : {execution_time:.2f} secondes")

print(f"Taille de all_results : {len(all_results)}")
# Affichage des r√©sultats
results_df = pd.DataFrame(all_results)

# V√©rifie combien de firmes sont pr√©sentes √† chaque p√©riode
firmes_par_periode = results_df.groupby("Period")["FirmID"].nunique()

# Affiche un tableau de diagnostic
print("\nDiagnostic du nombre de firmes par p√©riode :")
for period, count in firmes_par_periode.items():
    print(f"P√©riode {period} : {count} firmes uniques")

# Affichage de 5 firmes al√©atoires sur la derni√®re p√©riode
last_period_df = results_df[results_df["Period"] == num_periods - 1]

if len(last_period_df) >= 5:
    sample_firms = last_period_df.sample(5, random_state=1)
    print("\nExtrait de 5 firmes (p√©riode finale) :")
    print(sample_firms)
else:
    print("\n‚ö†Ô∏è Pas assez de firmes pour √©chantillonner 5 observations √† la p√©riode finale.")
    print(f"Nombre de firmes disponibles √† la p√©riode {num_periods - 1} :", len(last_period_df))
    sample_firms = pd.DataFrame()  # Valeur vide pour √©viter les erreurs plus loin

print("\nExtrait de 5 firmes (p√©riode finale) :")
print(sample_firms)

print("Nombre unique de firmes dans results_df :", results_df["FirmID"].nunique())
print("Liste des firmes manquantes :", set(range(num_firms)) - set(results_df["FirmID"].unique()))

plt.figure(figsize=(14, 7))

plt.figure(figsize=(14, 7))

for h, household in enumerate(household_list):
    if "BaseConsumption" in household and "DisposableIncome" in household:
        base = household["BaseConsumption"]
        dispo = household["DisposableIncome"]
        share = [b / d if d > 0.01 else np.nan for b, d in zip(base, dispo)]
        share = [s if s < 2 else np.nan for s in share]  # filtrage des valeurs aberrantes
        plt.plot(range(len(share)), share, alpha=0.3)

plt.xlabel("P√©riodes")
plt.ylabel("BaseConsumption / DisposableIncome")
plt.title("Part de la base consumption dans le revenu disponible par m√©nage")
plt.grid(True)
plt.tight_layout()
plt.show()


# √âvolution du capital brun pour 5 firmes al√©atoires
firm_ids = results_df["FirmID"].drop_duplicates().sample(5, random_state=1).tolist()
subset_df = results_df[(results_df["FirmID"].isin(firm_ids)) & (results_df["Simulation"] == 0)]

plt.figure(figsize=(12, 6))
sns.lineplot(data=subset_df, x="Period", y="BrownCapital", hue="FirmID", legend=True)
plt.title("√âvolution du capital brun pour 5 firmes | Simulation 1")
plt.xlabel("P√©riode")
plt.ylabel("BrownCapital")
plt.grid(True)
plt.tight_layout()
plt.show()

# 1. Capital vert moyen par sc√©nario
plt.figure(figsize=(10, 6))
sns.lineplot(data=results_df, x="Period", y="GreenCapital", hue="ScenarioName", estimator="mean", ci="sd")
plt.title("Capital vert moyen par sc√©nario")
plt.tight_layout()
plt.show()



# 2. Revenu disponible moyen par sc√©nario
plt.figure(figsize=(10, 6))
sns.lineplot(data=household_df, x="Period", y="DisposableIncome", hue="ScenarioName", estimator="mean", ci="sd")
plt.title("Revenu disponible moyen par sc√©nario")
plt.tight_layout()
plt.show()



# 4. Boxplot du capital vert √† t=24
plt.figure(figsize=(8, 6))
final_period = results_df[results_df["Period"] == 24]
sns.boxplot(data=final_period, x="ScenarioName", y="GreenCapital")
plt.title("Distribution du capital vert √† la fin (t=24)")
plt.tight_layout()
plt.show()

"""




# Heatmap du vote individuel par m√©nage
pivot_votes = vote_df.pivot(index="HouseholdID", columns="Period", values="VoteDecision")

plt.figure(figsize=(14, 10))
sns.heatmap(
    pivot_votes,
    cmap=sns.color_palette(["#d7191c", "#1a9641"], as_cmap=True),  # rouge = anti, vert = pro
    cbar_kws={'label': 'VoteDecision'},
    linewidths=0.1,
    linecolor='grey'
)
plt.title("Heatmap du vote pro-transition par m√©nage (0 = anti, 1 = pro)")
plt.xlabel("P√©riode")
plt.ylabel("M√©nage")
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 8))
for h_id in pivot_votes.index:
    periods_voted = pivot_votes.columns[pivot_votes.loc[h_id] == 1]
    plt.scatter(periods_voted, [h_id] * len(periods_voted), color="green", s=10, alpha=0.7)

plt.title("Votes pro-transition (1) par m√©nage et p√©riode")
plt.xlabel("P√©riode")
plt.ylabel("ID M√©nage")
plt.grid(True)
plt.tight_layout()
plt.show()

vote_prop = vote_df.groupby(["Period", "VoteDecision"]).size().unstack(fill_value=0)
vote_prop = vote_prop[[1, 0]]  # Met le pro-transition en premier
vote_prop_norm = vote_prop.div(vote_prop.sum(axis=1), axis=0)

vote_prop_norm.plot.area(figsize=(10, 6), color=["green", "red"])
plt.title("√âvolution de la r√©partition des votes (pro vs anti-transition)")
plt.xlabel("P√©riode")
plt.ylabel("Proportion")
plt.legend(["Pro-transition (1)", "Anti-transition (0)"])
plt.grid(True)
plt.tight_layout()
plt.show()



plt.figure(figsize=(14, 7))

for h_id in needsindex_df["HouseholdID"].unique():
    household_data = needsindex_df[needsindex_df["HouseholdID"] == h_id]
    plt.plot(household_data["Period"], household_data["NeedsIndex"], alpha=0.3)

plt.title("√âvolution du NeedsIndex par m√©nage (Simulation 0)")
plt.xlabel("P√©riode")
plt.ylabel("NeedsIndex")
plt.grid(True)
plt.tight_layout()
plt.show()




# √âvolution du capital vert pour les m√™mes firmes
plt.figure(figsize=(12, 6))
sns.lineplot(data=subset_df, x="Period", y="GreenCapital", hue="FirmID", legend=True)
plt.title("√âvolution du capital vert pour 5 firmes | Simulation 1")
plt.xlabel("P√©riode")
plt.ylabel("GreenCapital")
plt.grid(True)
plt.tight_layout()
plt.show()

# Boxplot du capital total √† 5 p√©riodes s√©lectionn√©es
plt.figure(figsize=(10, 6))
selected_periods = [2, 5, 9, 15, 24]
sns.boxplot(x="Period", y="TotalCapital", data=results_df[results_df["Period"].isin(selected_periods)])
plt.title("Distribution du capital total √† diff√©rentes p√©riodes")
plt.xlabel("P√©riode")
plt.ylabel("TotalCapital")
plt.grid(True)
plt.tight_layout()
plt.show()

# √âvolution de la contrainte de cr√©dit pour les 120 firmes
plt.figure(figsize=(14, 8))
sns.lineplot(
    data=results_df[results_df["Simulation"] == 0],
    x="Period",
    y="CreditConstraintVar",
    hue="FirmID",
    legend=False,
    alpha=0.5
)
plt.title("√âvolution de la contrainte de cr√©dit pour les 120 firmes | Simulation 1")
plt.xlabel("P√©riode")
plt.ylabel("CreditConstraintVar")
plt.grid(True)
plt.tight_layout()
plt.show()

# 1. Revenu moyen des m√©nages
plt.figure(figsize=(10, 5))
sns.lineplot(data=household_df, x="Period", y="Income", estimator="mean", ci="sd")
plt.title("Revenu moyen des m√©nages (Simulation 0)")
plt.grid(True)
plt.tight_layout()
plt.show()

# 2. Consommation moyenne
plt.figure(figsize=(10, 5))
sns.lineplot(data=household_df, x="Period", y="Consumption", estimator="mean", ci="sd")
plt.title("Consommation moyenne des m√©nages (Simulation 0)")
plt.grid(True)
plt.tight_layout()
plt.show()

# 3. Dette moyenne
plt.figure(figsize=(10, 5))
sns.lineplot(data=household_df, x="Period", y="Debt", estimator="mean", ci="sd")
plt.title("Dette moyenne des m√©nages (Simulation 0)")
plt.grid(True)
plt.tight_layout()
plt.show() """
